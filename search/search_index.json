{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"haskell.nix \u00b6 haskell.nix is an alternative Haskell infrastructure for Nix 1 . Features \u00b6 Drop-in support for Cabal projects Drop-in support for Stack projects Build any package of specific version in Stackage or Hackage Overridable configuration Cross compile Haskell packages See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison. \u21a9","title":"Introduction"},{"location":"#haskellnix","text":"haskell.nix is an alternative Haskell infrastructure for Nix 1 .","title":"haskell.nix"},{"location":"#features","text":"Drop-in support for Cabal projects Drop-in support for Stack projects Build any package of specific version in Stackage or Hackage Overridable configuration Cross compile Haskell packages See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison. \u21a9","title":"Features"},{"location":"architecture/","text":"Architecture \u00b6 There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |---> | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '--> .----------. <-' .--------------. | | plan-to-nix |----> | plan.nix |------.---> | pkgs.nix | <--- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |---> | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram nix-tools \u00b6 nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix . haskell.nix \u00b6 Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own. hackage.nix \u00b6 hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage. stackage.nix \u00b6 stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the respective packages from hackage.nix.","title":"Architecture"},{"location":"architecture/#architecture","text":"There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |---> | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '--> .----------. <-' .--------------. | | plan-to-nix |----> | plan.nix |------.---> | pkgs.nix | <--- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |---> | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram","title":"Architecture"},{"location":"architecture/#nix-tools","text":"nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix .","title":"nix-tools"},{"location":"architecture/#haskellnix","text":"Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own.","title":"haskell.nix"},{"location":"architecture/#hackagenix","text":"hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage.","title":"hackage.nix"},{"location":"architecture/#stackagenix","text":"stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the respective packages from hackage.nix.","title":"stackage.nix"},{"location":"changelog/","text":"This file contains a summary of changes to Haskell.nix and nix-tools that will impact users. Sep 8, 2020 \u00b6 Added the ability to generate coverage reports for packages and projects. Added the doCoverage module option that allows users to choose packages to enable coverage for. Added a doCoverage flag to the component builder that outputs HPC information when coverage is enabled. Added test for coverage. July 21, 2020 \u00b6 Removed components.all , use symlinkJoin on components.exes or shellFor if you need a shell. Added components argument to shellFor . July 21, 2020 \u00b6 Added GHC 8.8.4 and replaced 8.8.3 in tests and as the ghc used to build nix-tools for stack projects. July 20, 2020 \u00b6 Changed haskell-nix.roots and p.roots to single derivations. July 8, 2020 \u00b6 Removed sources.nixpkgs-default , use sources.nixpkgs instead. Removed ./nixpkgs directory, use (import ./. {}).sources or ./nix/sources.nix instead. Removes V1 interface for details on how to fix old code see: https://github.com/input-output-hk/haskell.nix/issues/709 Removed defaultCompilerNixName. cabalProject, cabalProject', hackage-project and hackage-package now require a compiler-nix-name argument. haskell-nix.tool and .tools now require a compiler-nix-name argument. New functions p.tool and p.tools (where p is a project) do not. Like shellFor { tools = ... } they will use the compiler nix name from the project (including stack projects where it is derived from the resolver). haskell-nix.alex and haskell-nix.happy have been removed. Use p.tool \"alex\" \"3.2.5\" or shellFor { tools = { alex = \"3.2.5\"; } } . haskell-nix.nix-tools -> haskell-nix.nix-tools.ghc883 (it includes the hpack exe now). haskell-nix.cabal-install -> p.tool \"cabal\" \"3.2.0.0\" or shellFor { tools = { cabal = \"3.2.0.0\"; } } haskell-nix.haskellNixRoots -> haskell-nix.roots ghc883 or p.roots June 25, 2020 \u00b6 Haddock docs are now built in their own derivation when needed (not as part of the component build). They should build automatically when something (such as shellFor ) attempts to accesses the .doc attribute of component. December 27, 2019 \u00b6 Fix overlays/bootstrap.nix to provide LLVM 6, not LLVM 5, to ghc-8.6.X compilers. November 18, 2019 \u00b6 Changed the cleanSourceHaskell to accept an attrset of src and (optional) name parameters. This allows you to keep the source derivation name constant, so that your builds are always cached. Usage of cleanSourceHaskell will need to be updated. October 12, 2019 \u00b6 shellFor no longer sets CABAL_CONFIG by default. This avoids surprising users, but means that Cabal may select a plan which is different to your Haskell.nix package set. If you would like the old behaviour, use shellFor { exactDeps = true; } . August 9, 2019 \u00b6 Add the haskellLib.collectComponents function. June 21, 2019 \u00b6 Add ghcWithPackages and ghcWithHoogle to hsPkgs ( documentation . Benchmark components can now build successfully. Reduced the closure bloat of nix-tools, and added closure size limit to CI. Added more reference documentation and set up auto-generated documentation for Module Options . Miscellaneous bug fixes. June 7, 2019 \u00b6 Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages. May 29, 2019 \u00b6 Added shellFor function to package set. May 28, 2019 \u00b6 Added snaphots and haskellPackages attributes to the Haskell.nix top-level. May 22, 2019 \u00b6 Add the cleanSourceHaskell utility function to the Haskell.nix top-level. May 21, 2019 \u00b6 Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo. May 20, 2019 \u00b6 Remove Travis CI in favour of Buildkite. May 17, 2019 \u00b6 Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually. Mar 15, 2019 \u00b6 overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"ChangeLog"},{"location":"changelog/#sep-8-2020","text":"Added the ability to generate coverage reports for packages and projects. Added the doCoverage module option that allows users to choose packages to enable coverage for. Added a doCoverage flag to the component builder that outputs HPC information when coverage is enabled. Added test for coverage.","title":"Sep 8, 2020"},{"location":"changelog/#july-21-2020","text":"Removed components.all , use symlinkJoin on components.exes or shellFor if you need a shell. Added components argument to shellFor .","title":"July 21, 2020"},{"location":"changelog/#july-21-2020_1","text":"Added GHC 8.8.4 and replaced 8.8.3 in tests and as the ghc used to build nix-tools for stack projects.","title":"July 21, 2020"},{"location":"changelog/#july-20-2020","text":"Changed haskell-nix.roots and p.roots to single derivations.","title":"July 20, 2020"},{"location":"changelog/#july-8-2020","text":"Removed sources.nixpkgs-default , use sources.nixpkgs instead. Removed ./nixpkgs directory, use (import ./. {}).sources or ./nix/sources.nix instead. Removes V1 interface for details on how to fix old code see: https://github.com/input-output-hk/haskell.nix/issues/709 Removed defaultCompilerNixName. cabalProject, cabalProject', hackage-project and hackage-package now require a compiler-nix-name argument. haskell-nix.tool and .tools now require a compiler-nix-name argument. New functions p.tool and p.tools (where p is a project) do not. Like shellFor { tools = ... } they will use the compiler nix name from the project (including stack projects where it is derived from the resolver). haskell-nix.alex and haskell-nix.happy have been removed. Use p.tool \"alex\" \"3.2.5\" or shellFor { tools = { alex = \"3.2.5\"; } } . haskell-nix.nix-tools -> haskell-nix.nix-tools.ghc883 (it includes the hpack exe now). haskell-nix.cabal-install -> p.tool \"cabal\" \"3.2.0.0\" or shellFor { tools = { cabal = \"3.2.0.0\"; } } haskell-nix.haskellNixRoots -> haskell-nix.roots ghc883 or p.roots","title":"July 8, 2020"},{"location":"changelog/#june-25-2020","text":"Haddock docs are now built in their own derivation when needed (not as part of the component build). They should build automatically when something (such as shellFor ) attempts to accesses the .doc attribute of component.","title":"June 25, 2020"},{"location":"changelog/#december-27-2019","text":"Fix overlays/bootstrap.nix to provide LLVM 6, not LLVM 5, to ghc-8.6.X compilers.","title":"December 27, 2019"},{"location":"changelog/#november-18-2019","text":"Changed the cleanSourceHaskell to accept an attrset of src and (optional) name parameters. This allows you to keep the source derivation name constant, so that your builds are always cached. Usage of cleanSourceHaskell will need to be updated.","title":"November 18, 2019"},{"location":"changelog/#october-12-2019","text":"shellFor no longer sets CABAL_CONFIG by default. This avoids surprising users, but means that Cabal may select a plan which is different to your Haskell.nix package set. If you would like the old behaviour, use shellFor { exactDeps = true; } .","title":"October 12, 2019"},{"location":"changelog/#august-9-2019","text":"Add the haskellLib.collectComponents function.","title":"August 9, 2019"},{"location":"changelog/#june-21-2019","text":"Add ghcWithPackages and ghcWithHoogle to hsPkgs ( documentation . Benchmark components can now build successfully. Reduced the closure bloat of nix-tools, and added closure size limit to CI. Added more reference documentation and set up auto-generated documentation for Module Options . Miscellaneous bug fixes.","title":"June 21, 2019"},{"location":"changelog/#june-7-2019","text":"Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages.","title":"June 7, 2019"},{"location":"changelog/#may-29-2019","text":"Added shellFor function to package set.","title":"May 29, 2019"},{"location":"changelog/#may-28-2019","text":"Added snaphots and haskellPackages attributes to the Haskell.nix top-level.","title":"May 28, 2019"},{"location":"changelog/#may-22-2019","text":"Add the cleanSourceHaskell utility function to the Haskell.nix top-level.","title":"May 22, 2019"},{"location":"changelog/#may-21-2019","text":"Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo.","title":"May 21, 2019"},{"location":"changelog/#may-20-2019","text":"Remove Travis CI in favour of Buildkite.","title":"May 20, 2019"},{"location":"changelog/#may-17-2019","text":"Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually.","title":"May 17, 2019"},{"location":"changelog/#mar-15-2019","text":"overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"Mar 15, 2019"},{"location":"iohk-nix/","text":"IOHK's nix tooling \u00b6 iohk-nix \u00b6 iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval <iohk_nix>; in if try.success then builtins.trace \"using host <iohk_nix>\" try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = \"${spec.url}/archive/${spec.rev}.tar.gz\"; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { \"url\": \"https://github.com/input-output-hk/iohk-nix\", \"rev\": \"c92f0119ef5814b0ed1f445c2fdcf8894e326294\", \"sha256\": \"05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm\", \"fetchSubmodules\": false } nix/pkgs.nix { pkgs ? import <nixpkgs> {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"IOHKs nix library"},{"location":"iohk-nix/#iohks-nix-tooling","text":"","title":"IOHK's nix tooling"},{"location":"iohk-nix/#iohk-nix","text":"iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval <iohk_nix>; in if try.success then builtins.trace \"using host <iohk_nix>\" try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = \"${spec.url}/archive/${spec.rev}.tar.gz\"; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { \"url\": \"https://github.com/input-output-hk/iohk-nix\", \"rev\": \"c92f0119ef5814b0ed1f445c2fdcf8894e326294\", \"sha256\": \"05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm\", \"fetchSubmodules\": false } nix/pkgs.nix { pkgs ? import <nixpkgs> {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"iohk-nix"},{"location":"motivation/","text":"Motivation \u00b6 Why do we need another Haskell infrastructure for Nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? Problems with the nixpkgs haskell infrastructure are covered in the following sections: Cross compilation \u00b6 nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time. Package sets \u00b6 We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides its own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set. Per component level control \u00b6 The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue. Cyclic dependencies \u00b6 The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components. Build times \u00b6 The Haskell builder in nixpkgs builds a package sequentially, first the library then the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized your build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum. More logic in nix \u00b6 The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date. Decoupling \u00b6 Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"Motivation"},{"location":"motivation/#motivation","text":"Why do we need another Haskell infrastructure for Nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? Problems with the nixpkgs haskell infrastructure are covered in the following sections:","title":"Motivation"},{"location":"motivation/#cross-compilation","text":"nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time.","title":"Cross compilation"},{"location":"motivation/#package-sets","text":"We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides its own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set.","title":"Package sets"},{"location":"motivation/#per-component-level-control","text":"The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue.","title":"Per component level control"},{"location":"motivation/#cyclic-dependencies","text":"The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components.","title":"Cyclic dependencies"},{"location":"motivation/#build-times","text":"The Haskell builder in nixpkgs builds a package sequentially, first the library then the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized your build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum.","title":"Build times"},{"location":"motivation/#more-logic-in-nix","text":"The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date.","title":"More logic in nix"},{"location":"motivation/#decoupling","text":"Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"Decoupling"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 General troubleshooting when using cabalProject / stackProject / project \u00b6 Does the cabal/stack build work? \u00b6 In haskell.nix , we strive to take the build configuration from the cabal/stack configuration files. So if you have a problem with your cabal/stack configuration, it is likely that you will have a problem with the haskell.nix build too. So the first thing to do is make sure that the build works with cabal or stack as normal. If it does work, then the haskell.nix one should as well. If, on the other hand, there is a failure, the cabal or stack build is usually easier to debug (or at least it is no longer a haskell.nix problem). Is the haskell.nix configuration completely in line with the cabal/stack configuration? \u00b6 The haskell.nix configuration can come apart from the cabal/stack configuration in a number of ways: Compiler version \u00b6 (Cabal users only. For stack users this comes from the snapshot, so stack and haskell.nix will agree.) The compiler version used by haskell.nix is selected by the compiler-nix-name argument; or if you do not specify it, by some default version (we recommend specifying it!). Cabal does not provide an easy way to pin a version of the compiler ( with-compiler lets you pick a particular executable, which is nearly but not quite what we want). Hence, the two can come apart. Make sure you are using the same compiler for the cabal build as for the haskell.nix build. Hackage index state \u00b6 (Cabal users only. For stack users, package versions come from the snapshot, so stack and haskell.nix will agree.) Cabal has the concept of the Hackage \"index state\". This is a timestamp, and it tells Cabal to behave \"as if\" it was seeing Hackage at that point in time. Pinning it is generally good for reproducibility regardless of whether you use haskell.nix (you can do so in cabal.project ). If you do not set an index-state in cabal.project , then Cabal will use the latest one based on when you last called cabal update , and haskell.nix will use the latest one it knows about from hackage.nix . These may not be the same! So if you use haskell.nix we strongly recommend pinning the index-state . Nix-only configuration options \u00b6 You can set configuration options in your Nix code that are not present in the cabal/stack configuration. For example, you might enable profiling. Where possible, try to do the configuration in your cabal/stack configuration, e.g. setting profiling: true in cabal.project . This will ensure that the two builds agree. If you want or need to set some of them in Nix, try bringing the two into sync temporarily for troubleshooting. Specific issues \u00b6 Why am I building GHC? \u00b6 It's easier to list the reverse: when will you not build GHC? You have configured the binary caches correctly. You are using one of the GHC versions built by our CI (have a look in ci.nix to see what gets built). You are using one of the nixpkgs versions used by our CI (you can access the sources for these through haskell.nix . If you think you are doing all of these and you still find you're building GHC, drop us a line. Why am I building lots of Haskell packages? \u00b6 We don't generally cache much of Hackage (there's a lot of it!), except for the parts which are used by our tests. So this is expected, unfortunately. How do I prevent the evaluation-time dependencies of my project from being garbage-collected? \u00b6 The haskell-nix.roots \"ghc884\" should include all the evaluation-time dependencies and the main build time dependencies of a project using ghc 8.8.4. So you can add that to the relevant GC root. In practice, if you're using a CI system like Hydra/Hercules, this means adding it to a job in release.nix / ci.nix .","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#general-troubleshooting-when-using-cabalprojectstackprojectproject","text":"","title":"General troubleshooting when using cabalProject/stackProject/project"},{"location":"troubleshooting/#does-the-cabalstack-build-work","text":"In haskell.nix , we strive to take the build configuration from the cabal/stack configuration files. So if you have a problem with your cabal/stack configuration, it is likely that you will have a problem with the haskell.nix build too. So the first thing to do is make sure that the build works with cabal or stack as normal. If it does work, then the haskell.nix one should as well. If, on the other hand, there is a failure, the cabal or stack build is usually easier to debug (or at least it is no longer a haskell.nix problem).","title":"Does the cabal/stack build work?"},{"location":"troubleshooting/#is-the-haskellnix-configuration-completely-in-line-with-the-cabalstack-configuration","text":"The haskell.nix configuration can come apart from the cabal/stack configuration in a number of ways:","title":"Is the haskell.nix configuration completely in line with the cabal/stack configuration?"},{"location":"troubleshooting/#compiler-version","text":"(Cabal users only. For stack users this comes from the snapshot, so stack and haskell.nix will agree.) The compiler version used by haskell.nix is selected by the compiler-nix-name argument; or if you do not specify it, by some default version (we recommend specifying it!). Cabal does not provide an easy way to pin a version of the compiler ( with-compiler lets you pick a particular executable, which is nearly but not quite what we want). Hence, the two can come apart. Make sure you are using the same compiler for the cabal build as for the haskell.nix build.","title":"Compiler version"},{"location":"troubleshooting/#hackage-index-state","text":"(Cabal users only. For stack users, package versions come from the snapshot, so stack and haskell.nix will agree.) Cabal has the concept of the Hackage \"index state\". This is a timestamp, and it tells Cabal to behave \"as if\" it was seeing Hackage at that point in time. Pinning it is generally good for reproducibility regardless of whether you use haskell.nix (you can do so in cabal.project ). If you do not set an index-state in cabal.project , then Cabal will use the latest one based on when you last called cabal update , and haskell.nix will use the latest one it knows about from hackage.nix . These may not be the same! So if you use haskell.nix we strongly recommend pinning the index-state .","title":"Hackage index state"},{"location":"troubleshooting/#nix-only-configuration-options","text":"You can set configuration options in your Nix code that are not present in the cabal/stack configuration. For example, you might enable profiling. Where possible, try to do the configuration in your cabal/stack configuration, e.g. setting profiling: true in cabal.project . This will ensure that the two builds agree. If you want or need to set some of them in Nix, try bringing the two into sync temporarily for troubleshooting.","title":"Nix-only configuration options"},{"location":"troubleshooting/#specific-issues","text":"","title":"Specific issues"},{"location":"troubleshooting/#why-am-i-building-ghc","text":"It's easier to list the reverse: when will you not build GHC? You have configured the binary caches correctly. You are using one of the GHC versions built by our CI (have a look in ci.nix to see what gets built). You are using one of the nixpkgs versions used by our CI (you can access the sources for these through haskell.nix . If you think you are doing all of these and you still find you're building GHC, drop us a line.","title":"Why am I building GHC?"},{"location":"troubleshooting/#why-am-i-building-lots-of-haskell-packages","text":"We don't generally cache much of Hackage (there's a lot of it!), except for the parts which are used by our tests. So this is expected, unfortunately.","title":"Why am I building lots of Haskell packages?"},{"location":"troubleshooting/#how-do-i-prevent-the-evaluation-time-dependencies-of-my-project-from-being-garbage-collected","text":"The haskell-nix.roots \"ghc884\" should include all the evaluation-time dependencies and the main build time dependencies of a project using ghc 8.8.4. So you can add that to the relevant GC root. In practice, if you're using a CI system like Hydra/Hercules, this means adding it to a job in release.nix / ci.nix .","title":"How do I prevent the evaluation-time dependencies of my project from being garbage-collected?"},{"location":"dev/adding-new-ghc/","text":"Adding a new GHC version to haskell.nix \u00b6 Update overlays/bootstrap.nix \u00b6 Each ghc version is defined in this file. Duplicate one of the existing ghc version definitions and replace the version numbers. Make sure you update the spec.sha256 or the other versions source will be used. Check the LLVM version that should be used in the ghc wiki . Update the list of cached GHC versions in ci.nix \u00b6 Update supported ghc versions document \u00b6 Add the materialized files \u00b6 In the haskell.nix repo run: mkdir materialized/ghc884 nix-build scripts/check-compiler-materialization --argstr compiler-nix-name ghc884 The nix-build command will fail with something like: Materialized nix used for dummy-data-x86_64-unknown-linux-musl-ghc-8.10.1 incorrect. To fix run: /nix/store/wnwpyrhv4nxgyljz3f20gdpspjxvm7h4-updateMaterialized Run the updateMaterialized script and repeat the nix-build until it no longer fails. If the failure is not a problem with materialization and no updateMaterialized script is provided then you may need to fix the failure another way or (if it only relates to one of the cross compilers) modify scripts/check-compiler-materialization/default.nix so that it skips that compiler.","title":"Adding a new GHC version"},{"location":"dev/adding-new-ghc/#adding-a-new-ghc-version-to-haskellnix","text":"","title":"Adding a new GHC version to haskell.nix"},{"location":"dev/adding-new-ghc/#update-overlaysbootstrapnix","text":"Each ghc version is defined in this file. Duplicate one of the existing ghc version definitions and replace the version numbers. Make sure you update the spec.sha256 or the other versions source will be used. Check the LLVM version that should be used in the ghc wiki .","title":"Update overlays/bootstrap.nix"},{"location":"dev/adding-new-ghc/#update-the-list-of-cached-ghc-versions-in-cinix","text":"","title":"Update the list of cached GHC versions in ci.nix"},{"location":"dev/adding-new-ghc/#update-supported-ghc-versions-document","text":"","title":"Update supported ghc versions document"},{"location":"dev/adding-new-ghc/#add-the-materialized-files","text":"In the haskell.nix repo run: mkdir materialized/ghc884 nix-build scripts/check-compiler-materialization --argstr compiler-nix-name ghc884 The nix-build command will fail with something like: Materialized nix used for dummy-data-x86_64-unknown-linux-musl-ghc-8.10.1 incorrect. To fix run: /nix/store/wnwpyrhv4nxgyljz3f20gdpspjxvm7h4-updateMaterialized Run the updateMaterialized script and repeat the nix-build until it no longer fails. If the failure is not a problem with materialization and no updateMaterialized script is provided then you may need to fix the failure another way or (if it only relates to one of the cross compilers) modify scripts/check-compiler-materialization/default.nix so that it skips that compiler.","title":"Add the materialized files"},{"location":"dev/coverage/","text":"Developer Coverage Overview \u00b6 Building \u00b6 The implementation of coverage starts with the \"doCoverage\" flag on the builder in comp-builder.nix . The doCoverage flag enables and disables the Cabal coverage flag and copies any generated coverage data to \"$out/share/hpc\". Mix and tix files \u00b6 The coverage information for any derivation consists of \"mix\" and \"tix\" files. Mix files record static information about a source file and are generated at build time. They primarily contain a path to the source file and information about expressions and regions of the source file, which are later referenced by tix files. Tix files contain dynamic information about a test run, recording when a portion of a source file is touched by a test. These are generated when the test is run. Multiple local packages \u00b6 In the context of multiple local packages, there are a few types of coverage we might be interested in: - How well does the tests for this package cover the package library? - How well does the tests for this package cover the libraries of other packages in this project? - Both of the above. To facilitate expressing any of these classifications of coverage, the lib/cover.nix function provides the mixLibraries argument. If you're just interested in how the tests cover the package library, you provide that library as an argument to mixLibraries . If you're interested in how the tests also cover other local packages in the project, you can also provide those libraries as arguments to mixLibraries. The projectCoverageReport and coverageReport attributes that are provided by default on projects and packages respectively provide coverage information for all local packages in the project. This is to mimic the behaviour of Stack, which seems to be the expectation of most people. Of course, you can use the projectCoverageReport and coverageReport functions to construct your own custom coverage reports (as detailed in the coverage tutorial ). Coverage reports \u00b6 Package reports \u00b6 The coverage information generated will look something like this: /nix/store/...-my-project-0.1.0.0-coverage-report/ \u2514\u2500\u2500 share \u2514\u2500\u2500 hpc \u2514\u2500\u2500 vanilla \u251c\u2500\u2500 html \u2502 \u2514\u2500\u2500 my-library-0.1.0.0 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.hs.html \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.hs.html \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.hs.html \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2514\u2500\u2500 hpc_index.html \u251c\u2500\u2500 mix \u2502 \u2514\u2500\u2500 my-library-0.1.0.0 \u2502 \u2514\u2500\u2500 my-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u251c\u2500\u2500 My.Lib.Config.mix \u2502 \u251c\u2500\u2500 My.Lib.Types.mix \u2502 \u2514\u2500\u2500 My.Lib.Util.mix \u2514\u2500\u2500 tix \u2514\u2500\u2500 my-library-0.1.0.0 \u251c\u2500\u2500 my-library-0.1.0.0.tix \u251c\u2500\u2500 my-test-1 \u2502 \u2514\u2500\u2500 my-test-1.tix \u2514\u2500\u2500 unit-test \u2514\u2500\u2500 unit-test.tix The mix files are copied verbatim from the library built with coverage. The tix files for each test are copied from the check run verbatim and are output to \".../tix/ / / .tix\". The tix files for each library are generated by summing the tix files for each test, but excluding any test modules. This tix file is output to \".../tix/ / .tix\". Test modules are determined by inspecting the plan for the project (i.e. for the project \"my-project\" and test-suite \"my-test-1\", the test modules are read from: my-project.checks.my-test-1.config.modules ) The hpc HTML reports for each library are generated from their respective tix files (i.e. the share/hpc/vanilla/html/my-library-0.1.0.0 report is generated from the share/hpc/vanilla/tix/my-library-0.1.0.0/my-library-0.1.0.0.tix file) Project-wide reports \u00b6 The coverage information for an entire project will look something like this: /nix/store/...-coverage-report \u2514\u2500\u2500 share \u2514\u2500\u2500 hpc \u2514\u2500\u2500 vanilla \u251c\u2500\u2500 html \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 all \u2502 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.hs.html \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.hs.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.hs.html \u2502 \u2502 \u251c\u2500\u2500 other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u2502 \u2502 \u251c\u2500\u2500 Other.Lib.A.hs.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 Other.Lib.B.hs.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2502 \u2514\u2500\u2500 hpc_index.html \u2502 \u251c\u2500\u2500 my-library-0.1.0.0 \u2502 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.hs.html \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.hs.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.hs.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2502 \u2514\u2500\u2500 hpc_index.html \u2502 \u2514\u2500\u2500 other-libray-0.1.0.0 \u2502 \u251c\u2500\u2500 other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u2502 \u251c\u2500\u2500 Other.Lib.A.hs.html \u2502 \u2502 \u2514\u2500\u2500 Other.Lib.B.hs.html \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2514\u2500\u2500 hpc_index.html \u251c\u2500\u2500 mix \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.mix \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.mix \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.mix \u2502 \u2514\u2500\u2500 other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u251c\u2500\u2500 Other.Lib.A.mix \u2502 \u2514\u2500\u2500 Other.Lib.B.mix \u2514\u2500\u2500 tix \u251c\u2500\u2500 all \u2502 \u2514\u2500\u2500 all.tix \u251c\u2500\u2500 my-library-0.1.0.0 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0.tix \u2502 \u251c\u2500\u2500 my-test-1 \u2502 \u2502 \u2514\u2500\u2500 my-test-1.tix \u2502 \u2514\u2500\u2500 unit-test \u2502 \u2514\u2500\u2500 unit-test.tix \u2514\u2500\u2500 another-library-0.1.0.0 \u251c\u2500\u2500 another-library-0.1.0.0.tix \u251c\u2500\u2500 my-test-2 \u2502 \u2514\u2500\u2500 my-test-2.tix \u2514\u2500\u2500 unit-test \u2514\u2500\u2500 unit-test.tix All of the coverage information is copied verbatim from the coverage reports for each of the constituent packages. A few additions are made: - tix/all/all.tix is generated from the union of all the library tix files. - We use this file when generating coverage reports for \"coveralls.io\". - An index page ( html/index.html ) is generated which links to the HTML coverage reports of the constituent packages. - A synthetic HTML report is generated from the tix/all/all.tix file. This shows the union of all the coverage information generated by each constituent coverage report.","title":"Coverage"},{"location":"dev/coverage/#developer-coverage-overview","text":"","title":"Developer Coverage Overview"},{"location":"dev/coverage/#building","text":"The implementation of coverage starts with the \"doCoverage\" flag on the builder in comp-builder.nix . The doCoverage flag enables and disables the Cabal coverage flag and copies any generated coverage data to \"$out/share/hpc\".","title":"Building"},{"location":"dev/coverage/#mix-and-tix-files","text":"The coverage information for any derivation consists of \"mix\" and \"tix\" files. Mix files record static information about a source file and are generated at build time. They primarily contain a path to the source file and information about expressions and regions of the source file, which are later referenced by tix files. Tix files contain dynamic information about a test run, recording when a portion of a source file is touched by a test. These are generated when the test is run.","title":"Mix and tix files"},{"location":"dev/coverage/#multiple-local-packages","text":"In the context of multiple local packages, there are a few types of coverage we might be interested in: - How well does the tests for this package cover the package library? - How well does the tests for this package cover the libraries of other packages in this project? - Both of the above. To facilitate expressing any of these classifications of coverage, the lib/cover.nix function provides the mixLibraries argument. If you're just interested in how the tests cover the package library, you provide that library as an argument to mixLibraries . If you're interested in how the tests also cover other local packages in the project, you can also provide those libraries as arguments to mixLibraries. The projectCoverageReport and coverageReport attributes that are provided by default on projects and packages respectively provide coverage information for all local packages in the project. This is to mimic the behaviour of Stack, which seems to be the expectation of most people. Of course, you can use the projectCoverageReport and coverageReport functions to construct your own custom coverage reports (as detailed in the coverage tutorial ).","title":"Multiple local packages"},{"location":"dev/coverage/#coverage-reports","text":"","title":"Coverage reports"},{"location":"dev/coverage/#package-reports","text":"The coverage information generated will look something like this: /nix/store/...-my-project-0.1.0.0-coverage-report/ \u2514\u2500\u2500 share \u2514\u2500\u2500 hpc \u2514\u2500\u2500 vanilla \u251c\u2500\u2500 html \u2502 \u2514\u2500\u2500 my-library-0.1.0.0 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.hs.html \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.hs.html \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.hs.html \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2514\u2500\u2500 hpc_index.html \u251c\u2500\u2500 mix \u2502 \u2514\u2500\u2500 my-library-0.1.0.0 \u2502 \u2514\u2500\u2500 my-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u251c\u2500\u2500 My.Lib.Config.mix \u2502 \u251c\u2500\u2500 My.Lib.Types.mix \u2502 \u2514\u2500\u2500 My.Lib.Util.mix \u2514\u2500\u2500 tix \u2514\u2500\u2500 my-library-0.1.0.0 \u251c\u2500\u2500 my-library-0.1.0.0.tix \u251c\u2500\u2500 my-test-1 \u2502 \u2514\u2500\u2500 my-test-1.tix \u2514\u2500\u2500 unit-test \u2514\u2500\u2500 unit-test.tix The mix files are copied verbatim from the library built with coverage. The tix files for each test are copied from the check run verbatim and are output to \".../tix/ / / .tix\". The tix files for each library are generated by summing the tix files for each test, but excluding any test modules. This tix file is output to \".../tix/ / .tix\". Test modules are determined by inspecting the plan for the project (i.e. for the project \"my-project\" and test-suite \"my-test-1\", the test modules are read from: my-project.checks.my-test-1.config.modules ) The hpc HTML reports for each library are generated from their respective tix files (i.e. the share/hpc/vanilla/html/my-library-0.1.0.0 report is generated from the share/hpc/vanilla/tix/my-library-0.1.0.0/my-library-0.1.0.0.tix file)","title":"Package reports"},{"location":"dev/coverage/#project-wide-reports","text":"The coverage information for an entire project will look something like this: /nix/store/...-coverage-report \u2514\u2500\u2500 share \u2514\u2500\u2500 hpc \u2514\u2500\u2500 vanilla \u251c\u2500\u2500 html \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 all \u2502 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.hs.html \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.hs.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.hs.html \u2502 \u2502 \u251c\u2500\u2500 other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u2502 \u2502 \u251c\u2500\u2500 Other.Lib.A.hs.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 Other.Lib.B.hs.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2502 \u2514\u2500\u2500 hpc_index.html \u2502 \u251c\u2500\u2500 my-library-0.1.0.0 \u2502 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.hs.html \u2502 \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.hs.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.hs.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2502 \u2514\u2500\u2500 hpc_index.html \u2502 \u2514\u2500\u2500 other-libray-0.1.0.0 \u2502 \u251c\u2500\u2500 other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u2502 \u251c\u2500\u2500 Other.Lib.A.hs.html \u2502 \u2502 \u2514\u2500\u2500 Other.Lib.B.hs.html \u2502 \u251c\u2500\u2500 hpc_index_alt.html \u2502 \u251c\u2500\u2500 hpc_index_exp.html \u2502 \u251c\u2500\u2500 hpc_index_fun.html \u2502 \u2514\u2500\u2500 hpc_index.html \u251c\u2500\u2500 mix \u2502 \u251c\u2500\u2500 my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Config.mix \u2502 \u2502 \u251c\u2500\u2500 My.Lib.Types.mix \u2502 \u2502 \u2514\u2500\u2500 My.Lib.Util.mix \u2502 \u2514\u2500\u2500 other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf \u2502 \u251c\u2500\u2500 Other.Lib.A.mix \u2502 \u2514\u2500\u2500 Other.Lib.B.mix \u2514\u2500\u2500 tix \u251c\u2500\u2500 all \u2502 \u2514\u2500\u2500 all.tix \u251c\u2500\u2500 my-library-0.1.0.0 \u2502 \u251c\u2500\u2500 my-library-0.1.0.0.tix \u2502 \u251c\u2500\u2500 my-test-1 \u2502 \u2502 \u2514\u2500\u2500 my-test-1.tix \u2502 \u2514\u2500\u2500 unit-test \u2502 \u2514\u2500\u2500 unit-test.tix \u2514\u2500\u2500 another-library-0.1.0.0 \u251c\u2500\u2500 another-library-0.1.0.0.tix \u251c\u2500\u2500 my-test-2 \u2502 \u2514\u2500\u2500 my-test-2.tix \u2514\u2500\u2500 unit-test \u2514\u2500\u2500 unit-test.tix All of the coverage information is copied verbatim from the coverage reports for each of the constituent packages. A few additions are made: - tix/all/all.tix is generated from the union of all the library tix files. - We use this file when generating coverage reports for \"coveralls.io\". - An index page ( html/index.html ) is generated which links to the HTML coverage reports of the constituent packages. - A synthetic HTML report is generated from the tix/all/all.tix file. This shows the union of all the coverage information generated by each constituent coverage report.","title":"Project-wide reports"},{"location":"dev/dev-architecture/","text":"Developer Architecture Overview \u00b6 This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble. Packages \u00b6 haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { \"library\" = { depends = [ ... ]; }; exes = { \"...\" = { depends = [ ... ]; }; ... }; sublibs = { \"...\" = { depends = [ ... ]; }; ... }; tests = { \"...\" = { depends = [ ... ]; }; ... }; benchmarks = { \"...\" = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix . Plans \u00b6 Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { \"$pkg\".revision = hackage.$pkg.$version.revisions.default; \"$pkg\".flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = \"8.4.4\"; nix-name = \"ghc844\"; packages = { \"binary\" = \"0.8.5.1\"; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section. Package Sets (of derivations) \u00b6 We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ). Component builder \u00b6 To prevent depending on multiple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Architecture"},{"location":"dev/dev-architecture/#developer-architecture-overview","text":"This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble.","title":"Developer Architecture Overview"},{"location":"dev/dev-architecture/#packages","text":"haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { \"library\" = { depends = [ ... ]; }; exes = { \"...\" = { depends = [ ... ]; }; ... }; sublibs = { \"...\" = { depends = [ ... ]; }; ... }; tests = { \"...\" = { depends = [ ... ]; }; ... }; benchmarks = { \"...\" = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix .","title":"Packages"},{"location":"dev/dev-architecture/#plans","text":"Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { \"$pkg\".revision = hackage.$pkg.$version.revisions.default; \"$pkg\".flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = \"8.4.4\"; nix-name = \"ghc844\"; packages = { \"binary\" = \"0.8.5.1\"; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section.","title":"Plans"},{"location":"dev/dev-architecture/#package-sets-of-derivations","text":"We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ).","title":"Package Sets (of derivations)"},{"location":"dev/dev-architecture/#component-builder","text":"To prevent depending on multiple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Component builder"},{"location":"dev/installing-nix-tools/","text":"Installing nix-tools \u00b6 To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz pkgs.haskell-nix.nix-tools.ghc884 --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt Optional: Installing via Haskell.nix source \u00b6 The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . pkgs.haskell-nix.nix-tools.ghc884 --arg sourcesOverride '{ nix-tools = ../nix-tools; }' --out-link nt","title":"Installing nix-tools"},{"location":"dev/installing-nix-tools/#installing-nix-tools","text":"To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz pkgs.haskell-nix.nix-tools.ghc884 --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt","title":"Installing nix-tools"},{"location":"dev/installing-nix-tools/#optional-installing-via-haskellnix-source","text":"The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . pkgs.haskell-nix.nix-tools.ghc884 --arg sourcesOverride '{ nix-tools = ../nix-tools; }' --out-link nt","title":"Optional: Installing via Haskell.nix source"},{"location":"dev/maintainer-scripts/","text":"Updating Hackage and Stackage Nix expressions \u00b6 The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Maintainer Scripts"},{"location":"dev/maintainer-scripts/#updating-hackage-and-stackage-nix-expressions","text":"The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Updating Hackage and Stackage Nix expressions"},{"location":"dev/manually-generating-nix-expressions/","text":"Manually generating Nix expressions \u00b6 We believe that imports from derivations (IFDs) provide tremendous value in nix and the aversion towards them stems mostly from poor tooling and ci support for them. We do not believe that poor tooling or ci support should cripple nix capability of abstraction. Hence haskell.nix makes excessive use of IFDs. We do note however that there are users who prefer to have IFD-free expressions. For this group of users we detail how to expand the IFD dependent high level functions into their IFD free building blocks. The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression (see the links bellow). The following file then produces a package set: # default.nix let # Import the Haskell.nix library, pkgs = import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = pkgs.haskell-nix.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in stack.yaml instead # (`stack-to-nix` will include them as defaults). ]; }; # Cabal projects use this: pkgSet = pkgs.haskell-nix.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in `cabal.project` instead # (`plan-to-nix` will include them as defaults). ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks. Using Stack \u00b6 With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = \"lts-12.17\"; extras = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ). Using Cabal \u00b6 Generating plan.json \u00b6 To get a plan, you need Cabal and GHC. See the How to install a compiler section of the Nixpkgs Manual for information about how to choose a specific compiler version. Cabal version The minimum Cabal version is 2.4. This version is available in the NixOS 19.03 release. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run \"cabal new-configure\" If all goes well, you should now have the file dist-newstyle/cache/plan.json . Specifying the GHC version To use a specific compiler version, replace haskellPackages.ghc with something like haskell-nix.compiler.ghc865 . The given compiler must exist in your Nixpkgs version, of course. See also the Nixpkgs Manual . Using plan-to-nix \u00b6 With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description.","title":"Manually generating Nix expressions"},{"location":"dev/manually-generating-nix-expressions/#manually-generating-nix-expressions","text":"We believe that imports from derivations (IFDs) provide tremendous value in nix and the aversion towards them stems mostly from poor tooling and ci support for them. We do not believe that poor tooling or ci support should cripple nix capability of abstraction. Hence haskell.nix makes excessive use of IFDs. We do note however that there are users who prefer to have IFD-free expressions. For this group of users we detail how to expand the IFD dependent high level functions into their IFD free building blocks. The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression (see the links bellow). The following file then produces a package set: # default.nix let # Import the Haskell.nix library, pkgs = import <nixpkgs> (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = pkgs.haskell-nix.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in stack.yaml instead # (`stack-to-nix` will include them as defaults). ]; }; # Cabal projects use this: pkgSet = pkgs.haskell-nix.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = \"-Werror\"; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in `cabal.project` instead # (`plan-to-nix` will include them as defaults). ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks.","title":"Manually generating Nix expressions"},{"location":"dev/manually-generating-nix-expressions/#using-stack","text":"With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = \"lts-12.17\"; extras = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ).","title":"Using Stack"},{"location":"dev/manually-generating-nix-expressions/#using-cabal","text":"","title":"Using Cabal"},{"location":"dev/manually-generating-nix-expressions/#generating-planjson","text":"To get a plan, you need Cabal and GHC. See the How to install a compiler section of the Nixpkgs Manual for information about how to choose a specific compiler version. Cabal version The minimum Cabal version is 2.4. This version is available in the NixOS 19.03 release. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run \"cabal new-configure\" If all goes well, you should now have the file dist-newstyle/cache/plan.json . Specifying the GHC version To use a specific compiler version, replace haskellPackages.ghc with something like haskell-nix.compiler.ghc865 . The given compiler must exist in your Nixpkgs version, of course. See also the Nixpkgs Manual .","title":"Generating plan.json"},{"location":"dev/manually-generating-nix-expressions/#using-plan-to-nix","text":"With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { \"o-clock\" = hackage.o-clock.\"0.1.1\".revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description.","title":"Using plan-to-nix"},{"location":"dev/nixpkgs-pin/","text":"Haskell.nix Nixpkgs Pin \u00b6 Haskell.nix contains a Nixpkgs pin in nixpkgs/github.json . This is the version of Nixpkgs used for builds of nix-tools and running the tests. To use haskell.nix the config and overlays need to be applied to Nixpkgs. Users should probably pin a suitable version of nixpkgs, although things might not work for them if their Nixpkgs version is too different. We aim to keep this pin somewhere on a channel of the Nixpkgs latest stable release . That is currently 19.09. We also execute tests on MacOS (darwin). The darwin channel is usually behind the NixOS channel. So we choose the nixpkgs-19.09-darwin channel: nix-prefetch-git https://github.com/NixOS/nixpkgs-channels refs/heads/nixpkgs-19.09-darwin Keep the URL in github.json pointing at https://github.com/NixOS/nixpkgs . Case matters because the Hydra trusted URL whitelist is case-sensitive.","title":"Nixpkgs Pin"},{"location":"dev/nixpkgs-pin/#haskellnix-nixpkgs-pin","text":"Haskell.nix contains a Nixpkgs pin in nixpkgs/github.json . This is the version of Nixpkgs used for builds of nix-tools and running the tests. To use haskell.nix the config and overlays need to be applied to Nixpkgs. Users should probably pin a suitable version of nixpkgs, although things might not work for them if their Nixpkgs version is too different. We aim to keep this pin somewhere on a channel of the Nixpkgs latest stable release . That is currently 19.09. We also execute tests on MacOS (darwin). The darwin channel is usually behind the NixOS channel. So we choose the nixpkgs-19.09-darwin channel: nix-prefetch-git https://github.com/NixOS/nixpkgs-channels refs/heads/nixpkgs-19.09-darwin Keep the URL in github.json pointing at https://github.com/NixOS/nixpkgs . Case matters because the Hydra trusted URL whitelist is case-sensitive.","title":"Haskell.nix Nixpkgs Pin"},{"location":"dev/removing-with-package-wrapper/","text":"ghcWithPackages wrapper removal \u00b6 The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone. Plain ghc \u00b6 When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well. ghc-pkg \u00b6 The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set. Setup.hs \u00b6 When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages. cabal new-build \u00b6 Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"Removing withPackage wrapper"},{"location":"dev/removing-with-package-wrapper/#ghcwithpackages-wrapper-removal","text":"The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone.","title":"ghcWithPackages wrapper removal"},{"location":"dev/removing-with-package-wrapper/#plain-ghc","text":"When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well.","title":"Plain ghc"},{"location":"dev/removing-with-package-wrapper/#ghc-pkg","text":"The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set.","title":"ghc-pkg"},{"location":"dev/removing-with-package-wrapper/#setuphs","text":"When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages.","title":"Setup.hs"},{"location":"dev/removing-with-package-wrapper/#cabal-new-build","text":"Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"cabal new-build"},{"location":"dev/tests/","text":"Haskell infrastructure test cases \u00b6 To build the test cases, run from the test directory: nix-build --no-out-link default.nix To run all tests (includes impure tests), use the script: ./tests.sh Generated code \u00b6 If you change the test Cabal files or need to regenerate the code with nix-tools, then see regen.nix . Run it like this: $(nix-build --no-out-link regen.nix)","title":"Test Suite"},{"location":"dev/tests/#haskell-infrastructure-test-cases","text":"To build the test cases, run from the test directory: nix-build --no-out-link default.nix To run all tests (includes impure tests), use the script: ./tests.sh","title":"Haskell infrastructure test cases"},{"location":"dev/tests/#generated-code","text":"If you change the test Cabal files or need to regenerate the code with nix-tools, then see regen.nix . Run it like this: $(nix-build --no-out-link regen.nix)","title":"Generated code"},{"location":"reference/commands/","text":"stack-to-nix \u00b6 stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: \"stack.yaml\") --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: \".stack-to-nix.cache\") -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache (The open issue is #57 ). plan-to-nix \u00b6 plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: \"dist-newstyle/cache/plan.json\") --cabal-project FILE Override path to cabal.project (default: \"cabal.project\") --cache FILE Dependency cache file (default: \".nix-tools.cache\") -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Note If you find that there are missing files which should have been generated, remove .nix-tools.cache (The open issue is #57 ). cabal-to-nix \u00b6 Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"Command-line tools"},{"location":"reference/commands/#stack-to-nix","text":"stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: \"stack.yaml\") --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: \".stack-to-nix.cache\") -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache (The open issue is #57 ).","title":"stack-to-nix"},{"location":"reference/commands/#plan-to-nix","text":"plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: \"dist-newstyle/cache/plan.json\") --cabal-project FILE Override path to cabal.project (default: \"cabal.project\") --cache FILE Dependency cache file (default: \".nix-tools.cache\") -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Note If you find that there are missing files which should have been generated, remove .nix-tools.cache (The open issue is #57 ).","title":"plan-to-nix"},{"location":"reference/commands/#cabal-to-nix","text":"Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"cabal-to-nix"},{"location":"reference/library/","text":"Haskell.nix contains a library of functions for creating buildable package sets from their Nix expression descriptions. The library is what you get when importing Haskell.nix . It might be helpful to load the library in the Nix REPL to test things. Data structures \u2014 the kinds of data that you will encounter working with Haskell.nix . Top-level attributes \u2014 Functions and derivations defined in the Haskell.nix attrset. Package-set functions \u2014 Helper functions defined on the hsPkgs package set. Data structures \u00b6 Package Set \u00b6 The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = \"X.Y.Z\"; nix-name = \"ghcXYZ\"; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset Haskell Package description \u00b6 The Haskell package descriptions are values of the pkgSet.config.packages attrset. These are not derivations, but just the configuration for building an individual package. The configuration options are described under packages.<name> in Module options . Component description \u00b6 The component descriptions are values of the pkgSet.config.packages.<package>.components attrset. These are not derivations, but just the configuration for building an individual component. The configuration options are described under packages.<name>.components.* in Module options . Haskell Package \u00b6 In Haskell.nix , a Haskell package is a derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; } Component \u00b6 In Haskell.nix , a component is a derivation corresponding to a Cabal component of a package. Identifier \u00b6 A package identifier is an attrset pair of name and version . Extras \u00b6 Extras allow adding more packages to the package set. These will be functions taking a single parameter hackage . They should return an attrset of package descriptions. Modules \u00b6 Modules are the primary method of configuring building of the package set. They are either: an attrset containing option declarations , or a function that returns an attrset containing option declarations. If using the function form of a module, the following named parameters will be passed to it: Argument Type Description haskellLib attrset The haskellLib utility functions. pkgs The Nixpkgs collection. pkgconfPkgs A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this) buildModules config options Top-level attributes \u00b6 project \u00b6 Function that accepts attribute set with a src attribute and looks for stack.yaml file relative to it. If file exists, it calls stackProject function. Otherwise it will call cabalProject function. Example : pkgs.haskell-nix.project { # 'cleanGit' cleans a source directory based on the files known by git src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; } stackProject \u00b6 A function calling callStackToNix with all arguments. Then feeding its result into mkStackPkgSet passing also pkg-def-extras and modules arguments. Return value : Attribute Type Description hsPkgs Attrset of Haskell Packages Buildable packages, created from packages pkg-set Attrset pkgSet stack-nix projectNix attribute of callStackToNix return value shellFor Function shellFor ghcWithHoogle Function ghcWithHoogle ghcWithPackages Function ghcWithPackages cabalProject \u00b6 A function calling callCabalProjectToNix with all arguments. Then feeding its result into mkCabalProjectPkgSet passing also pkg-def-extras , extra-hackages and modules arguments. Return value : Attribute Type Description hsPkgs Attrset of Haskell Packages Buildable packages, created from packages pkg-set Attrset pkgSet plan-nix projectNix attribute of callCabalProjectToNix return value index-state index-state attribute of callCabalProjectToNix return value shellFor Function shellFor ghcWithHoogle Function ghcWithHoogle ghcWithPackages Function ghcWithPackages mkStackPkgSet \u00b6 Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkCabalProjectPkgSet \u00b6 Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkPkgSet \u00b6 This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet snapshots \u00b6 This is an attrset of hsPkgs packages from Stackage. haskellPackages \u00b6 A hsPkgs package set, which is one of the recent LTS Haskell releases from snapshots . The chosen LTS is updated occasionally in Haskell.nix , though a manual process. nix-tools \u00b6 A derivation containing the nix-tools command-line tools . callStackToNix \u00b6 Runs stack-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkStackPkgSet { stack-pkgs = (importAndFilterProject (callStackToNix { src = ./.; })).pkgs; pkg-def-extras = []; modules = []; }; callCabalProjectToNix \u00b6 Runs cabal new-configure and plan-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkCabalProjectPkgSet { plan-pkgs = (importAndFilterProject (callCabalProjectToNix { index-state = \"2019-04-30T00:00:00Z\"; src = ./.; })).pkgs; Argument Type Description name String Optional name for better error messages. src Path Location of the cabal project files. compiler-nix-name String The name of the ghc compiler to use eg. \"ghc884\" index-state Timestamp Optional hackage index-state, eg. \"2019-10-10T00:00:00Z\". index-sha256 Sha256 Optional hash of the truncated hackage index-state. plan-sha256 Sha256 Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation). cabalProject String Optional cabal project file contents (defaults to readFile \"${src}/cabal.project\"). cabalProjectLocal String Optional cabal project file contents (defaults to readFile \"${src}/cabal.project.local\"). cabalProjectFreeze String Optional cabal project file contents (defaults to readFile \"${src}/cabal.project.freeze\"). ghc Deprecated. Use compiler-nix-name instead. Optional ghc to use nix-tools Optional nix-tools to use hpack Optional hpack to use cabal-install Optional cabal-install to use configureArgs String Optional extra arguments to pass to cabal new-configure (--enable-tests is included by default, include --disable-tests to override that). importAndFilterProject \u00b6 Imports from a derivation created by callStackToNix or callCabalProjectToNix . The result is an attrset with the following values: Attribute Type Description pkgs attrset that can be passed to mkStackPkgSet (as stack-pkgs ) or mkCabalProjectPkgSet (as plan-pkgs ). nix this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra). hackage \u00b6 stackage \u00b6 fetchExternal \u00b6 cleanSourceHaskell \u00b6 cleanSourceHaskell = { src, name ? null }: ... Filters a source tree removing common filenames that are not Haskell build sources. This can avoid unecessary rebuilds when these files change. It's recommended to provide name so that the source derivation remains constant regardless of how it was fetched. Example: src = pkgs.haskell-nix.cleanSourceHaskell { src = ./.; name = \"myproject-src\"; }; haskellSourceFilter \u00b6 haskellSourceFilter = name: type: ... This is a source filter function which cleans common build products and files not needed to do a Haskell build from a source directory. It should be used with pkgs.lib.cleanSourceWith . Alternatively, use the convenience function cleanSourceHaskell . haskellLib \u00b6 Assorted functions for operating on Haskell.nix data. This is distinct from pkgs.haskell.lib in the current Nixpkgs Haskell Infrastructure. collectComponents, collectComponents' \u00b6 Extracts a selection of components from a Haskell package set . This can be used to filter out all test suites or benchmarks of your project, so that they can be built in Hydra (see check if you want to run the tests as well as build them). collectComponents' is an alias of collectComponents without predicate for filtering. collectComponents = group: packageSel: haskellPackages: ... collectComponents' = group: collectComponents (_: true) Argument Type Description group String A sub-component type . packageSel A function Package -> Bool A predicate to filter packages with. haskellPackages Package set All packages in the build. Return value : a recursive attrset mapping package names \u2192 component names \u2192 components. Example : tests = collectComponents \"tests\" (package: package.identifier.name == \"mypackage\") hsPkgs; Will result in moving derivations from hsPkgs.mypackage.components.tests.unit-tests to tests.mypackage.unit-tests . collectChecks, collectChecks' \u00b6 These are just like collectComponents and collectComponents' , except that they collect the checks attributes of packages (which aren't components, and so can't be collected by the other functions. check \u00b6 This function turns a derivation that builds a test into one to run it. Argument Type Description drv Derivation One of $pkg.components.tests.$test . For convenience $pkg.components.tests are mapped with this function to $pkg.checks . This function is intended for use with tests but it should also work for exes and benchmarks if you just want to run them to make sure they execute. subComponentTypes \u00b6 Sub-component types identify components and are one of: sublibs foreignlibs exes tests benchmarks Package-set functions \u00b6 These functions exist within the hsPkgs package set. shellFor \u00b6 Create a nix-shell development environment for developing one or more packages with ghci or cabal v2-build (but not Stack). shellFor = { packages, withHoogle ? true, exactDeps ? false, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. components Function Similar to packages , by default all the components of the selected packages are selected. additional Function Similar to packages , but the selected packages are built and included in ghc-pkg list (not just their dependencies). withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. exactDeps Boolean Prevents the Cabal solver from choosing any package dependency other than what are in the package set. tools Function AttrSet of tools to make available e.g. { cabal = \"3.2.0.0\"; } or { cabal = { version = \"3.2.0.0\"; }; } { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation Warning exactDeps = true will set the CABAL_CONFIG environment variable to disable remote package servers. This is a known limitation which we would like to solve. Use exactDeps = false if this is a problem. ghcWithPackages \u00b6 Creates a nix-shell development environment including the given packages selected from this package set. Parameter : a package selection function. Return value : a derivation Example : haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ]) ghcWithHoogle \u00b6 The same as ghcWithPackages , except, a hoogle command with a Hoogle documentation index of the packages will be included in the shell.","title":"Haskell.nix Library"},{"location":"reference/library/#data-structures","text":"","title":"Data structures"},{"location":"reference/library/#package-set","text":"The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = \"X.Y.Z\"; nix-name = \"ghcXYZ\"; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset","title":"Package Set"},{"location":"reference/library/#haskell-package-description","text":"The Haskell package descriptions are values of the pkgSet.config.packages attrset. These are not derivations, but just the configuration for building an individual package. The configuration options are described under packages.<name> in Module options .","title":"Haskell Package description"},{"location":"reference/library/#component-description","text":"The component descriptions are values of the pkgSet.config.packages.<package>.components attrset. These are not derivations, but just the configuration for building an individual component. The configuration options are described under packages.<name>.components.* in Module options .","title":"Component description"},{"location":"reference/library/#haskell-package","text":"In Haskell.nix , a Haskell package is a derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; }","title":"Haskell Package"},{"location":"reference/library/#component","text":"In Haskell.nix , a component is a derivation corresponding to a Cabal component of a package.","title":"Component"},{"location":"reference/library/#identifier","text":"A package identifier is an attrset pair of name and version .","title":"Identifier"},{"location":"reference/library/#extras","text":"Extras allow adding more packages to the package set. These will be functions taking a single parameter hackage . They should return an attrset of package descriptions.","title":"Extras"},{"location":"reference/library/#modules","text":"Modules are the primary method of configuring building of the package set. They are either: an attrset containing option declarations , or a function that returns an attrset containing option declarations. If using the function form of a module, the following named parameters will be passed to it: Argument Type Description haskellLib attrset The haskellLib utility functions. pkgs The Nixpkgs collection. pkgconfPkgs A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this) buildModules config options","title":"Modules"},{"location":"reference/library/#top-level-attributes","text":"","title":"Top-level attributes"},{"location":"reference/library/#project","text":"Function that accepts attribute set with a src attribute and looks for stack.yaml file relative to it. If file exists, it calls stackProject function. Otherwise it will call cabalProject function. Example : pkgs.haskell-nix.project { # 'cleanGit' cleans a source directory based on the files known by git src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; }","title":"project"},{"location":"reference/library/#stackproject","text":"A function calling callStackToNix with all arguments. Then feeding its result into mkStackPkgSet passing also pkg-def-extras and modules arguments. Return value : Attribute Type Description hsPkgs Attrset of Haskell Packages Buildable packages, created from packages pkg-set Attrset pkgSet stack-nix projectNix attribute of callStackToNix return value shellFor Function shellFor ghcWithHoogle Function ghcWithHoogle ghcWithPackages Function ghcWithPackages","title":"stackProject"},{"location":"reference/library/#cabalproject","text":"A function calling callCabalProjectToNix with all arguments. Then feeding its result into mkCabalProjectPkgSet passing also pkg-def-extras , extra-hackages and modules arguments. Return value : Attribute Type Description hsPkgs Attrset of Haskell Packages Buildable packages, created from packages pkg-set Attrset pkgSet plan-nix projectNix attribute of callCabalProjectToNix return value index-state index-state attribute of callCabalProjectToNix return value shellFor Function shellFor ghcWithHoogle Function ghcWithHoogle ghcWithPackages Function ghcWithPackages","title":"cabalProject"},{"location":"reference/library/#mkstackpkgset","text":"Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkStackPkgSet"},{"location":"reference/library/#mkcabalprojectpkgset","text":"Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkCabalProjectPkgSet"},{"location":"reference/library/#mkpkgset","text":"This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet","title":"mkPkgSet"},{"location":"reference/library/#snapshots","text":"This is an attrset of hsPkgs packages from Stackage.","title":"snapshots"},{"location":"reference/library/#haskellpackages","text":"A hsPkgs package set, which is one of the recent LTS Haskell releases from snapshots . The chosen LTS is updated occasionally in Haskell.nix , though a manual process.","title":"haskellPackages"},{"location":"reference/library/#nix-tools","text":"A derivation containing the nix-tools command-line tools .","title":"nix-tools"},{"location":"reference/library/#callstacktonix","text":"Runs stack-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkStackPkgSet { stack-pkgs = (importAndFilterProject (callStackToNix { src = ./.; })).pkgs; pkg-def-extras = []; modules = []; };","title":"callStackToNix"},{"location":"reference/library/#callcabalprojecttonix","text":"Runs cabal new-configure and plan-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkCabalProjectPkgSet { plan-pkgs = (importAndFilterProject (callCabalProjectToNix { index-state = \"2019-04-30T00:00:00Z\"; src = ./.; })).pkgs; Argument Type Description name String Optional name for better error messages. src Path Location of the cabal project files. compiler-nix-name String The name of the ghc compiler to use eg. \"ghc884\" index-state Timestamp Optional hackage index-state, eg. \"2019-10-10T00:00:00Z\". index-sha256 Sha256 Optional hash of the truncated hackage index-state. plan-sha256 Sha256 Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation). cabalProject String Optional cabal project file contents (defaults to readFile \"${src}/cabal.project\"). cabalProjectLocal String Optional cabal project file contents (defaults to readFile \"${src}/cabal.project.local\"). cabalProjectFreeze String Optional cabal project file contents (defaults to readFile \"${src}/cabal.project.freeze\"). ghc Deprecated. Use compiler-nix-name instead. Optional ghc to use nix-tools Optional nix-tools to use hpack Optional hpack to use cabal-install Optional cabal-install to use configureArgs String Optional extra arguments to pass to cabal new-configure (--enable-tests is included by default, include --disable-tests to override that).","title":"callCabalProjectToNix"},{"location":"reference/library/#importandfilterproject","text":"Imports from a derivation created by callStackToNix or callCabalProjectToNix . The result is an attrset with the following values: Attribute Type Description pkgs attrset that can be passed to mkStackPkgSet (as stack-pkgs ) or mkCabalProjectPkgSet (as plan-pkgs ). nix this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra).","title":"importAndFilterProject"},{"location":"reference/library/#hackage","text":"","title":"hackage"},{"location":"reference/library/#stackage","text":"","title":"stackage"},{"location":"reference/library/#fetchexternal","text":"","title":"fetchExternal"},{"location":"reference/library/#cleansourcehaskell","text":"cleanSourceHaskell = { src, name ? null }: ... Filters a source tree removing common filenames that are not Haskell build sources. This can avoid unecessary rebuilds when these files change. It's recommended to provide name so that the source derivation remains constant regardless of how it was fetched. Example: src = pkgs.haskell-nix.cleanSourceHaskell { src = ./.; name = \"myproject-src\"; };","title":"cleanSourceHaskell"},{"location":"reference/library/#haskellsourcefilter","text":"haskellSourceFilter = name: type: ... This is a source filter function which cleans common build products and files not needed to do a Haskell build from a source directory. It should be used with pkgs.lib.cleanSourceWith . Alternatively, use the convenience function cleanSourceHaskell .","title":"haskellSourceFilter"},{"location":"reference/library/#haskelllib","text":"Assorted functions for operating on Haskell.nix data. This is distinct from pkgs.haskell.lib in the current Nixpkgs Haskell Infrastructure.","title":"haskellLib"},{"location":"reference/library/#collectcomponents-collectcomponents","text":"Extracts a selection of components from a Haskell package set . This can be used to filter out all test suites or benchmarks of your project, so that they can be built in Hydra (see check if you want to run the tests as well as build them). collectComponents' is an alias of collectComponents without predicate for filtering. collectComponents = group: packageSel: haskellPackages: ... collectComponents' = group: collectComponents (_: true) Argument Type Description group String A sub-component type . packageSel A function Package -> Bool A predicate to filter packages with. haskellPackages Package set All packages in the build. Return value : a recursive attrset mapping package names \u2192 component names \u2192 components. Example : tests = collectComponents \"tests\" (package: package.identifier.name == \"mypackage\") hsPkgs; Will result in moving derivations from hsPkgs.mypackage.components.tests.unit-tests to tests.mypackage.unit-tests .","title":"collectComponents, collectComponents'"},{"location":"reference/library/#collectchecks-collectchecks","text":"These are just like collectComponents and collectComponents' , except that they collect the checks attributes of packages (which aren't components, and so can't be collected by the other functions.","title":"collectChecks, collectChecks'"},{"location":"reference/library/#check","text":"This function turns a derivation that builds a test into one to run it. Argument Type Description drv Derivation One of $pkg.components.tests.$test . For convenience $pkg.components.tests are mapped with this function to $pkg.checks . This function is intended for use with tests but it should also work for exes and benchmarks if you just want to run them to make sure they execute.","title":"check"},{"location":"reference/library/#subcomponenttypes","text":"Sub-component types identify components and are one of: sublibs foreignlibs exes tests benchmarks","title":"subComponentTypes"},{"location":"reference/library/#package-set-functions","text":"These functions exist within the hsPkgs package set.","title":"Package-set functions"},{"location":"reference/library/#shellfor","text":"Create a nix-shell development environment for developing one or more packages with ghci or cabal v2-build (but not Stack). shellFor = { packages, withHoogle ? true, exactDeps ? false, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. components Function Similar to packages , by default all the components of the selected packages are selected. additional Function Similar to packages , but the selected packages are built and included in ghc-pkg list (not just their dependencies). withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. exactDeps Boolean Prevents the Cabal solver from choosing any package dependency other than what are in the package set. tools Function AttrSet of tools to make available e.g. { cabal = \"3.2.0.0\"; } or { cabal = { version = \"3.2.0.0\"; }; } { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation Warning exactDeps = true will set the CABAL_CONFIG environment variable to disable remote package servers. This is a known limitation which we would like to solve. Use exactDeps = false if this is a problem.","title":"shellFor"},{"location":"reference/library/#ghcwithpackages","text":"Creates a nix-shell development environment including the given packages selected from this package set. Parameter : a package selection function. Return value : a derivation Example : haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ])","title":"ghcWithPackages"},{"location":"reference/library/#ghcwithhoogle","text":"The same as ghcWithPackages , except, a hoogle command with a Hoogle documentation index of the packages will be included in the shell.","title":"ghcWithHoogle"},{"location":"reference/modules/","text":"Haskell.nix modules options for packages and components. Generated This documentation is generated from Nix sources in the modules subdirectory using scripts/update-docs.nix Configuration Options \u00b6 bootPkgs \u00b6 This option has no description. Type : list of strings No Default No Example buildable \u00b6 This option has no description. Type : boolean Default : true No Example cabal.compiler \u00b6 This option has no description. Type : unspecified No Default No Example cabal.system \u00b6 This option has no description. Type : unspecified No Default No Example compiler.nix-name \u00b6 This option has no description. Type : string No Default No Example compiler.packages \u00b6 This option has no description. Type : attribute set of strings No Default No Example compiler.version \u00b6 This option has no description. Type : string No Default No Example configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example doCheck \u00b6 This option has no description. Type : boolean Default : true No Example doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example errorHandler \u00b6 This option has no description. Type : unspecified No Default No Example ghc.package \u00b6 This option has no description. Type : package Default : \"pkgs.buildPackages.haskell-nix.compiler.${config.compiler.nix-name}\" No Example hackage.configs \u00b6 This option has no description. Type : unspecified No Default No Example hackage.db \u00b6 This option has no description. Type : unspecified No Default No Example hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example hsPkgs \u00b6 This option has no description. Type : unspecified No Default No Example keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example nonReinstallablePkgs \u00b6 This option has no description. Type : list of strings No Default No Example packages \u00b6 This option has no description. Type : attribute set of submodules No Default No Example packages. .buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .cabal-generator \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks \u00b6 This option has no description. Type : attribute set of submodules Default : {} No Example packages. .components.benchmarks. .asmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .build-tools \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.benchmarks. .cSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .cmmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.benchmarks. .cxxSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.benchmarks. .doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .components.benchmarks. .doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .components.benchmarks. .doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.benchmarks. .doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .components.benchmarks. .doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .components.benchmarks. .doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .components.benchmarks. .doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .components.benchmarks. .dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .components.benchmarks. .dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .components.benchmarks. .enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .components.benchmarks. .enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.benchmarks. .enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.benchmarks. .enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.benchmarks. .enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .components.benchmarks. .enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .components.benchmarks. .extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .frameworks \u00b6 This option has no description. Type : list of packages Default : [] No Example packages. .components.benchmarks. .hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.benchmarks. .hsSourceDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [\".\"] No Example packages. .components.benchmarks. .includeDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .includes \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .jsSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .components.benchmarks. .libs \u00b6 This option has no description. Type : list of null or packages Default : [] No Example packages. .components.benchmarks. .mainPath \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .modules \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.benchmarks. .pkgconfig \u00b6 This option has no description. Type : list of list of packagess Default : [] No Example packages. .components.benchmarks. .platforms \u00b6 This option has no description. Type : null or list of unspecifieds Default : null No Example packages. .components.benchmarks. .postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.benchmarks. .preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .components.benchmarks. .profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .components.benchmarks. .setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.benchmarks. .setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.benchmarks. .setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.benchmarks. .shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .components.benchmarks. .testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.benchmarks. .testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" packages. .components.exes \u00b6 This option has no description. Type : attribute set of submodules Default : {} No Example packages. .components.exes. .asmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .build-tools \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.exes. .cSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .cmmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.exes. .cxxSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.exes. .doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .components.exes. .doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .components.exes. .doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.exes. .doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .components.exes. .doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .components.exes. .doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .components.exes. .doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .components.exes. .dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .components.exes. .dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .components.exes. .enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .components.exes. .enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.exes. .enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.exes. .enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.exes. .enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .components.exes. .enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .components.exes. .extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .frameworks \u00b6 This option has no description. Type : list of packages Default : [] No Example packages. .components.exes. .hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.exes. .hsSourceDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [\".\"] No Example packages. .components.exes. .includeDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .includes \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .jsSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .components.exes. .libs \u00b6 This option has no description. Type : list of null or packages Default : [] No Example packages. .components.exes. .mainPath \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .modules \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.exes. .pkgconfig \u00b6 This option has no description. Type : list of list of packagess Default : [] No Example packages. .components.exes. .platforms \u00b6 This option has no description. Type : null or list of unspecifieds Default : null No Example packages. .components.exes. .postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.exes. .preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .components.exes. .profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .components.exes. .setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.exes. .setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.exes. .setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.exes. .shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .components.exes. .testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.exes. .testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" packages. .components.foreignlibs \u00b6 This option has no description. Type : attribute set of submodules Default : {} No Example packages. .components.foreignlibs. .asmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .build-tools \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.foreignlibs. .cSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .cmmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.foreignlibs. .cxxSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.foreignlibs. .doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .components.foreignlibs. .doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .components.foreignlibs. .doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.foreignlibs. .doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .components.foreignlibs. .doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .components.foreignlibs. .doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .components.foreignlibs. .doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .components.foreignlibs. .dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .components.foreignlibs. .dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .components.foreignlibs. .enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .components.foreignlibs. .enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.foreignlibs. .enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.foreignlibs. .enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.foreignlibs. .enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .components.foreignlibs. .enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .components.foreignlibs. .extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .frameworks \u00b6 This option has no description. Type : list of packages Default : [] No Example packages. .components.foreignlibs. .hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.foreignlibs. .hsSourceDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [\".\"] No Example packages. .components.foreignlibs. .includeDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .includes \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .jsSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .components.foreignlibs. .libs \u00b6 This option has no description. Type : list of null or packages Default : [] No Example packages. .components.foreignlibs. .mainPath \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .modules \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.foreignlibs. .pkgconfig \u00b6 This option has no description. Type : list of list of packagess Default : [] No Example packages. .components.foreignlibs. .platforms \u00b6 This option has no description. Type : null or list of unspecifieds Default : null No Example packages. .components.foreignlibs. .postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.foreignlibs. .preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .components.foreignlibs. .profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .components.foreignlibs. .setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.foreignlibs. .setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.foreignlibs. .setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.foreignlibs. .shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .components.foreignlibs. .testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.foreignlibs. .testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" packages. .components.library \u00b6 This option has no description. Type : null or submodule Default : null No Example packages. .components.library.asmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.build-tools \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.library.cSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.cmmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.library.cxxSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.library.doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .components.library.doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .components.library.doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.library.doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .components.library.doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .components.library.doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .components.library.doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .components.library.dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .components.library.dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .components.library.enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .components.library.enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.library.enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.library.enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.library.enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .components.library.enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .components.library.extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.frameworks \u00b6 This option has no description. Type : list of packages Default : [] No Example packages. .components.library.hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.library.hsSourceDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [\".\"] No Example packages. .components.library.includeDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.includes \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.jsSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .components.library.libs \u00b6 This option has no description. Type : list of null or packages Default : [] No Example packages. .components.library.mainPath \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.modules \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.library.pkgconfig \u00b6 This option has no description. Type : list of list of packagess Default : [] No Example packages. .components.library.platforms \u00b6 This option has no description. Type : null or list of unspecifieds Default : null No Example packages. .components.library.postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.library.preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .components.library.profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .components.library.setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.library.setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.library.setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.library.shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .components.library.testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.library.testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" packages. .components.setup \u00b6 This option has no description. Type : null or submodule Default : {\"asmSources\":[],\"cSources\":[],\"cmmSources\":[],\"cxxSources\":[],\"depends\":[],\"doExactConfig\":false,\"extraSrcFiles\":[\"Setup.hs\",\"Setup.lhs\"],\"frameworks\":[],\"hsSourceDirs\":[\"setup-src\"],\"includeDirs\":[],\"jsSources\":[],\"libs\":[],\"platforms\":null} No Example packages. .components.setup.asmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.build-tools \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.setup.cSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.cmmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.setup.cxxSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.setup.doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .components.setup.doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .components.setup.doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.setup.doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .components.setup.doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .components.setup.doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .components.setup.doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .components.setup.dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .components.setup.dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .components.setup.enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .components.setup.enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.setup.enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.setup.enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.setup.enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .components.setup.enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .components.setup.extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.frameworks \u00b6 This option has no description. Type : list of packages Default : [] No Example packages. .components.setup.hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.setup.hsSourceDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [\".\"] No Example packages. .components.setup.includeDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.includes \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.jsSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .components.setup.libs \u00b6 This option has no description. Type : list of null or packages Default : [] No Example packages. .components.setup.mainPath \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.modules \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.setup.pkgconfig \u00b6 This option has no description. Type : list of list of packagess Default : [] No Example packages. .components.setup.platforms \u00b6 This option has no description. Type : null or list of unspecifieds Default : null No Example packages. .components.setup.postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.setup.preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .components.setup.profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .components.setup.setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.setup.setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.setup.setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.setup.shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .components.setup.testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.setup.testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" packages. .components.sublibs \u00b6 This option has no description. Type : attribute set of submodules Default : {} No Example packages. .components.sublibs. .asmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .build-tools \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.sublibs. .cSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .cmmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.sublibs. .cxxSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.sublibs. .doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .components.sublibs. .doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .components.sublibs. .doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.sublibs. .doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .components.sublibs. .doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .components.sublibs. .doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .components.sublibs. .doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .components.sublibs. .dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .components.sublibs. .dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .components.sublibs. .enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .components.sublibs. .enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.sublibs. .enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.sublibs. .enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.sublibs. .enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .components.sublibs. .enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .components.sublibs. .extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .frameworks \u00b6 This option has no description. Type : list of packages Default : [] No Example packages. .components.sublibs. .hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.sublibs. .hsSourceDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [\".\"] No Example packages. .components.sublibs. .includeDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .includes \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .jsSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .components.sublibs. .libs \u00b6 This option has no description. Type : list of null or packages Default : [] No Example packages. .components.sublibs. .mainPath \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .modules \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.sublibs. .pkgconfig \u00b6 This option has no description. Type : list of list of packagess Default : [] No Example packages. .components.sublibs. .platforms \u00b6 This option has no description. Type : null or list of unspecifieds Default : null No Example packages. .components.sublibs. .postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.sublibs. .preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .components.sublibs. .profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .components.sublibs. .setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.sublibs. .setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.sublibs. .setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.sublibs. .shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .components.sublibs. .testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.sublibs. .testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" packages. .components.tests \u00b6 This option has no description. Type : attribute set of submodules Default : {} No Example packages. .components.tests. .asmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .build-tools \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .buildable \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.tests. .cSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .cmmSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.tests. .cxxSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .components.tests. .doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .components.tests. .doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .components.tests. .doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.tests. .doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .components.tests. .doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .components.tests. .doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .components.tests. .doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .components.tests. .dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .components.tests. .dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .components.tests. .enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .components.tests. .enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.tests. .enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.tests. .enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .components.tests. .enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .components.tests. .enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .components.tests. .extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .frameworks \u00b6 This option has no description. Type : list of packages Default : [] No Example packages. .components.tests. .hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.tests. .hsSourceDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [\".\"] No Example packages. .components.tests. .includeDirs \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .includes \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .jsSources \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .components.tests. .libs \u00b6 This option has no description. Type : list of null or packages Default : [] No Example packages. .components.tests. .mainPath \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .modules \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .components.tests. .pkgconfig \u00b6 This option has no description. Type : list of list of packagess Default : [] No Example packages. .components.tests. .platforms \u00b6 This option has no description. Type : null or list of unspecifieds Default : null No Example packages. .components.tests. .postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .components.tests. .preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .components.tests. .profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .components.tests. .setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.tests. .setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.tests. .setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.tests. .shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .components.tests. .testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .components.tests. .testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" packages. .configureFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .doCheck \u00b6 This option has no description. Type : boolean Default : true No Example packages. .doCoverage \u00b6 Enable production of test coverage reports. Type : boolean Default : false No Example packages. .doCrossCheck \u00b6 Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example packages. .doExactConfig \u00b6 This option has no description. Type : boolean Default : false No Example packages. .doHaddock \u00b6 Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example packages. .doHoogle \u00b6 Also build a hoogle index. Type : boolean Default : true No Example packages. .doHyperlinkSource \u00b6 Link documentation to the source code. Type : boolean Default : true No Example packages. .doQuickjump \u00b6 Generate an index for interactive documentation navigation. Type : boolean Default : true No Example packages. .dontPatchELF \u00b6 If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example packages. .dontStrip \u00b6 If set, libraries and executables are not stripped. Type : boolean Default : true No Example packages. .enableDeadCodeElimination \u00b6 If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example packages. .enableExecutableProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .enableLibraryProfiling \u00b6 This option has no description. Type : boolean Default : false No Example packages. .enableSeparateDataOutput \u00b6 This option has no description. Type : boolean Default : false No Example packages. .enableShared \u00b6 If set, enables building shared libraries. Type : boolean Default : true No Example packages. .enableStatic \u00b6 If set, enables building static libraries and executables. Type : boolean Default : true No Example packages. .flags \u00b6 This option has no description. Type : attribute set of booleans No Default No Example packages. .hardeningDisable \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .keepSource \u00b6 Keep component source in the store in a source output Type : boolean Default : false No Example packages. .name \u00b6 This option has no description. Type : string Default : \"${config.package.identifier.name}-${config.package.identifier.version}\" No Example packages. .package.author \u00b6 This option has no description. Type : string No Default No Example packages. .package.buildType \u00b6 This option has no description. Type : string No Default No Example packages. .package.cleanHpack \u00b6 This option has no description. Type : boolean Default : false No Example packages. .package.copyright \u00b6 This option has no description. Type : string No Default No Example packages. .package.dataDir \u00b6 This option has no description. Type : string Default : \"\" No Example packages. .package.dataFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .package.description \u00b6 This option has no description. Type : string No Default No Example packages. .package.detailLevel \u00b6 This option has no description. Type : string Default : \"MinimalDetails\" No Example packages. .package.extraDocFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .package.extraSrcFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .package.extraTmpFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .package.ghcOptions \u00b6 This option has no description. Type : null or string Default : null No Example packages. .package.homepage \u00b6 This option has no description. Type : string No Default No Example packages. .package.identifier.name \u00b6 This option has no description. Type : string No Default No Example packages. .package.identifier.version \u00b6 This option has no description. Type : string No Default No Example packages. .package.isLocal \u00b6 This option has no description. Type : boolean Default : false No Example packages. .package.license \u00b6 This option has no description. Type : string No Default No Example packages. .package.licenseFiles \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .package.maintainer \u00b6 This option has no description. Type : string No Default No Example packages. .package.setup-depends \u00b6 This option has no description. Type : list of unspecifieds Default : [] No Example packages. .package.specVersion \u00b6 This option has no description. Type : string No Default No Example packages. .package.synopsis \u00b6 This option has no description. Type : string No Default No Example packages. .package.url \u00b6 This option has no description. Type : string No Default No Example packages. .patches \u00b6 This option has no description. Type : list of unspecified or paths Default : [] No Example packages. .postBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .postCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .postInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example packages. .preBuild \u00b6 This option has no description. Type : null or string Default : null No Example packages. .preCheck \u00b6 This option has no description. Type : null or string Default : null No Example packages. .preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example packages. .preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example packages. .preInstall \u00b6 This option has no description. Type : null or string Default : null No Example packages. .preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example packages. .profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example packages. .revision \u00b6 This option has no description. Type : null or signed integer Default : null No Example packages. .revisionSha256 \u00b6 This option has no description. Type : null or string Default : null No Example packages. .setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .sha256 \u00b6 This option has no description. Type : null or string Default : null No Example packages. .shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example packages. .src \u00b6 This option has no description. Type : path or package Default : \"pkgs.fetchurl { url = \\\"mirror://hackage/${config.name}.tar.gz\\\"; inherit (config) sha256; };\" No Example packages. .testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example packages. .testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\" postBuild \u00b6 This option has no description. Type : null or string Default : null No Example postCheck \u00b6 This option has no description. Type : null or string Default : null No Example postConfigure \u00b6 This option has no description. Type : null or string Default : null No Example postHaddock \u00b6 This option has no description. Type : null or string Default : null No Example postInstall \u00b6 This option has no description. Type : null or string Default : null No Example postUnpack \u00b6 This option has no description. Type : null or string Default : null No Example preBuild \u00b6 This option has no description. Type : null or string Default : null No Example preCheck \u00b6 This option has no description. Type : null or string Default : null No Example preConfigure \u00b6 This option has no description. Type : null or string Default : null No Example preHaddock \u00b6 This option has no description. Type : null or string Default : null No Example preInstall \u00b6 This option has no description. Type : null or string Default : null No Example preUnpack \u00b6 This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example profilingDetail \u00b6 This option has no description. Type : null or string Default : \"default\" No Example reinstallableLibGhc \u00b6 Is lib:ghc reinstallable? Type : boolean Default : false No Example setup-depends \u00b6 pkgs to globally provide to Setup.hs builds Type : list of unspecifieds Default : [] No Example setupBuildFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example setupHaddockFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example setupInstallFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example shellHook \u00b6 Hook to run when entering a shell Type : unspecified Default : \"\" No Example testFlags \u00b6 This option has no description. Type : list of strings Default : [] No Example testWrapper \u00b6 A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"Module options"},{"location":"reference/modules/#configuration-options","text":"","title":"Configuration Options"},{"location":"reference/modules/#bootpkgs","text":"This option has no description. Type : list of strings No Default No Example","title":"bootPkgs"},{"location":"reference/modules/#buildable","text":"This option has no description. Type : boolean Default : true No Example","title":"buildable"},{"location":"reference/modules/#cabalcompiler","text":"This option has no description. Type : unspecified No Default No Example","title":"cabal.compiler"},{"location":"reference/modules/#cabalsystem","text":"This option has no description. Type : unspecified No Default No Example","title":"cabal.system"},{"location":"reference/modules/#compilernix-name","text":"This option has no description. Type : string No Default No Example","title":"compiler.nix-name"},{"location":"reference/modules/#compilerpackages","text":"This option has no description. Type : attribute set of strings No Default No Example","title":"compiler.packages"},{"location":"reference/modules/#compilerversion","text":"This option has no description. Type : string No Default No Example","title":"compiler.version"},{"location":"reference/modules/#configureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"configureFlags"},{"location":"reference/modules/#docheck","text":"This option has no description. Type : boolean Default : true No Example","title":"doCheck"},{"location":"reference/modules/#docoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"doCoverage"},{"location":"reference/modules/#docrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"doCrossCheck"},{"location":"reference/modules/#doexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"doExactConfig"},{"location":"reference/modules/#dohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"doHaddock"},{"location":"reference/modules/#dohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"doHoogle"},{"location":"reference/modules/#dohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"doHyperlinkSource"},{"location":"reference/modules/#doquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"doQuickjump"},{"location":"reference/modules/#dontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"dontPatchELF"},{"location":"reference/modules/#dontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"dontStrip"},{"location":"reference/modules/#enabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"enableDeadCodeElimination"},{"location":"reference/modules/#enableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"enableExecutableProfiling"},{"location":"reference/modules/#enablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"enableLibraryProfiling"},{"location":"reference/modules/#enableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"enableSeparateDataOutput"},{"location":"reference/modules/#enableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"enableShared"},{"location":"reference/modules/#enablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"enableStatic"},{"location":"reference/modules/#errorhandler","text":"This option has no description. Type : unspecified No Default No Example","title":"errorHandler"},{"location":"reference/modules/#ghcpackage","text":"This option has no description. Type : package Default : \"pkgs.buildPackages.haskell-nix.compiler.${config.compiler.nix-name}\" No Example","title":"ghc.package"},{"location":"reference/modules/#hackageconfigs","text":"This option has no description. Type : unspecified No Default No Example","title":"hackage.configs"},{"location":"reference/modules/#hackagedb","text":"This option has no description. Type : unspecified No Default No Example","title":"hackage.db"},{"location":"reference/modules/#hardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"hardeningDisable"},{"location":"reference/modules/#hspkgs","text":"This option has no description. Type : unspecified No Default No Example","title":"hsPkgs"},{"location":"reference/modules/#keepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"keepSource"},{"location":"reference/modules/#nonreinstallablepkgs","text":"This option has no description. Type : list of strings No Default No Example","title":"nonReinstallablePkgs"},{"location":"reference/modules/#packages","text":"This option has no description. Type : attribute set of submodules No Default No Example","title":"packages"},{"location":"reference/modules/#packagesbuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..buildable"},{"location":"reference/modules/#packagescabal-generator","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..cabal-generator"},{"location":"reference/modules/#packagescomponentsbenchmarks","text":"This option has no description. Type : attribute set of submodules Default : {} No Example","title":"packages..components.benchmarks"},{"location":"reference/modules/#packagescomponentsbenchmarksasmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..asmSources"},{"location":"reference/modules/#packagescomponentsbenchmarksbuild-tools","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..build-tools"},{"location":"reference/modules/#packagescomponentsbenchmarksbuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.benchmarks..buildable"},{"location":"reference/modules/#packagescomponentsbenchmarkscsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..cSources"},{"location":"reference/modules/#packagescomponentsbenchmarkscmmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..cmmSources"},{"location":"reference/modules/#packagescomponentsbenchmarksconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.benchmarks..configureFlags"},{"location":"reference/modules/#packagescomponentsbenchmarkscxxsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..cxxSources"},{"location":"reference/modules/#packagescomponentsbenchmarksdepends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..depends"},{"location":"reference/modules/#packagescomponentsbenchmarksdocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.benchmarks..doCheck"},{"location":"reference/modules/#packagescomponentsbenchmarksdocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..components.benchmarks..doCoverage"},{"location":"reference/modules/#packagescomponentsbenchmarksdocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..components.benchmarks..doCrossCheck"},{"location":"reference/modules/#packagescomponentsbenchmarksdoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.benchmarks..doExactConfig"},{"location":"reference/modules/#packagescomponentsbenchmarksdohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..components.benchmarks..doHaddock"},{"location":"reference/modules/#packagescomponentsbenchmarksdohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..components.benchmarks..doHoogle"},{"location":"reference/modules/#packagescomponentsbenchmarksdohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..components.benchmarks..doHyperlinkSource"},{"location":"reference/modules/#packagescomponentsbenchmarksdoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..components.benchmarks..doQuickjump"},{"location":"reference/modules/#packagescomponentsbenchmarksdontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..components.benchmarks..dontPatchELF"},{"location":"reference/modules/#packagescomponentsbenchmarksdontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..components.benchmarks..dontStrip"},{"location":"reference/modules/#packagescomponentsbenchmarksenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..components.benchmarks..enableDeadCodeElimination"},{"location":"reference/modules/#packagescomponentsbenchmarksenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.benchmarks..enableExecutableProfiling"},{"location":"reference/modules/#packagescomponentsbenchmarksenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.benchmarks..enableLibraryProfiling"},{"location":"reference/modules/#packagescomponentsbenchmarksenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.benchmarks..enableSeparateDataOutput"},{"location":"reference/modules/#packagescomponentsbenchmarksenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..components.benchmarks..enableShared"},{"location":"reference/modules/#packagescomponentsbenchmarksenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..components.benchmarks..enableStatic"},{"location":"reference/modules/#packagescomponentsbenchmarksextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..extraSrcFiles"},{"location":"reference/modules/#packagescomponentsbenchmarksframeworks","text":"This option has no description. Type : list of packages Default : [] No Example","title":"packages..components.benchmarks..frameworks"},{"location":"reference/modules/#packagescomponentsbenchmarkshardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.benchmarks..hardeningDisable"},{"location":"reference/modules/#packagescomponentsbenchmarkshssourcedirs","text":"This option has no description. Type : list of unspecifieds Default : [\".\"] No Example","title":"packages..components.benchmarks..hsSourceDirs"},{"location":"reference/modules/#packagescomponentsbenchmarksincludedirs","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..includeDirs"},{"location":"reference/modules/#packagescomponentsbenchmarksincludes","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..includes"},{"location":"reference/modules/#packagescomponentsbenchmarksjssources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..jsSources"},{"location":"reference/modules/#packagescomponentsbenchmarkskeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..components.benchmarks..keepSource"},{"location":"reference/modules/#packagescomponentsbenchmarkslibs","text":"This option has no description. Type : list of null or packages Default : [] No Example","title":"packages..components.benchmarks..libs"},{"location":"reference/modules/#packagescomponentsbenchmarksmainpath","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..mainPath"},{"location":"reference/modules/#packagescomponentsbenchmarksmodules","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.benchmarks..modules"},{"location":"reference/modules/#packagescomponentsbenchmarkspkgconfig","text":"This option has no description. Type : list of list of packagess Default : [] No Example","title":"packages..components.benchmarks..pkgconfig"},{"location":"reference/modules/#packagescomponentsbenchmarksplatforms","text":"This option has no description. Type : null or list of unspecifieds Default : null No Example","title":"packages..components.benchmarks..platforms"},{"location":"reference/modules/#packagescomponentsbenchmarkspostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..postBuild"},{"location":"reference/modules/#packagescomponentsbenchmarkspostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..postCheck"},{"location":"reference/modules/#packagescomponentsbenchmarkspostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..postConfigure"},{"location":"reference/modules/#packagescomponentsbenchmarksposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..postHaddock"},{"location":"reference/modules/#packagescomponentsbenchmarkspostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..postInstall"},{"location":"reference/modules/#packagescomponentsbenchmarkspostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..postUnpack"},{"location":"reference/modules/#packagescomponentsbenchmarksprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..preBuild"},{"location":"reference/modules/#packagescomponentsbenchmarksprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..preCheck"},{"location":"reference/modules/#packagescomponentsbenchmarkspreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..preConfigure"},{"location":"reference/modules/#packagescomponentsbenchmarksprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..preHaddock"},{"location":"reference/modules/#packagescomponentsbenchmarkspreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.benchmarks..preInstall"},{"location":"reference/modules/#packagescomponentsbenchmarkspreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..components.benchmarks..preUnpack"},{"location":"reference/modules/#packagescomponentsbenchmarksprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..components.benchmarks..profilingDetail"},{"location":"reference/modules/#packagescomponentsbenchmarkssetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.benchmarks..setupBuildFlags"},{"location":"reference/modules/#packagescomponentsbenchmarkssetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.benchmarks..setupHaddockFlags"},{"location":"reference/modules/#packagescomponentsbenchmarkssetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.benchmarks..setupInstallFlags"},{"location":"reference/modules/#packagescomponentsbenchmarksshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..components.benchmarks..shellHook"},{"location":"reference/modules/#packagescomponentsbenchmarkstestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.benchmarks..testFlags"},{"location":"reference/modules/#packagescomponentsbenchmarkstestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..components.benchmarks..testWrapper"},{"location":"reference/modules/#packagescomponentsexes","text":"This option has no description. Type : attribute set of submodules Default : {} No Example","title":"packages..components.exes"},{"location":"reference/modules/#packagescomponentsexesasmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..asmSources"},{"location":"reference/modules/#packagescomponentsexesbuild-tools","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..build-tools"},{"location":"reference/modules/#packagescomponentsexesbuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.exes..buildable"},{"location":"reference/modules/#packagescomponentsexescsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..cSources"},{"location":"reference/modules/#packagescomponentsexescmmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..cmmSources"},{"location":"reference/modules/#packagescomponentsexesconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.exes..configureFlags"},{"location":"reference/modules/#packagescomponentsexescxxsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..cxxSources"},{"location":"reference/modules/#packagescomponentsexesdepends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..depends"},{"location":"reference/modules/#packagescomponentsexesdocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.exes..doCheck"},{"location":"reference/modules/#packagescomponentsexesdocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..components.exes..doCoverage"},{"location":"reference/modules/#packagescomponentsexesdocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..components.exes..doCrossCheck"},{"location":"reference/modules/#packagescomponentsexesdoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.exes..doExactConfig"},{"location":"reference/modules/#packagescomponentsexesdohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..components.exes..doHaddock"},{"location":"reference/modules/#packagescomponentsexesdohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..components.exes..doHoogle"},{"location":"reference/modules/#packagescomponentsexesdohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..components.exes..doHyperlinkSource"},{"location":"reference/modules/#packagescomponentsexesdoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..components.exes..doQuickjump"},{"location":"reference/modules/#packagescomponentsexesdontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..components.exes..dontPatchELF"},{"location":"reference/modules/#packagescomponentsexesdontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..components.exes..dontStrip"},{"location":"reference/modules/#packagescomponentsexesenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..components.exes..enableDeadCodeElimination"},{"location":"reference/modules/#packagescomponentsexesenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.exes..enableExecutableProfiling"},{"location":"reference/modules/#packagescomponentsexesenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.exes..enableLibraryProfiling"},{"location":"reference/modules/#packagescomponentsexesenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.exes..enableSeparateDataOutput"},{"location":"reference/modules/#packagescomponentsexesenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..components.exes..enableShared"},{"location":"reference/modules/#packagescomponentsexesenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..components.exes..enableStatic"},{"location":"reference/modules/#packagescomponentsexesextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..extraSrcFiles"},{"location":"reference/modules/#packagescomponentsexesframeworks","text":"This option has no description. Type : list of packages Default : [] No Example","title":"packages..components.exes..frameworks"},{"location":"reference/modules/#packagescomponentsexeshardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.exes..hardeningDisable"},{"location":"reference/modules/#packagescomponentsexeshssourcedirs","text":"This option has no description. Type : list of unspecifieds Default : [\".\"] No Example","title":"packages..components.exes..hsSourceDirs"},{"location":"reference/modules/#packagescomponentsexesincludedirs","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..includeDirs"},{"location":"reference/modules/#packagescomponentsexesincludes","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..includes"},{"location":"reference/modules/#packagescomponentsexesjssources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..jsSources"},{"location":"reference/modules/#packagescomponentsexeskeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..components.exes..keepSource"},{"location":"reference/modules/#packagescomponentsexeslibs","text":"This option has no description. Type : list of null or packages Default : [] No Example","title":"packages..components.exes..libs"},{"location":"reference/modules/#packagescomponentsexesmainpath","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..mainPath"},{"location":"reference/modules/#packagescomponentsexesmodules","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.exes..modules"},{"location":"reference/modules/#packagescomponentsexespkgconfig","text":"This option has no description. Type : list of list of packagess Default : [] No Example","title":"packages..components.exes..pkgconfig"},{"location":"reference/modules/#packagescomponentsexesplatforms","text":"This option has no description. Type : null or list of unspecifieds Default : null No Example","title":"packages..components.exes..platforms"},{"location":"reference/modules/#packagescomponentsexespostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..postBuild"},{"location":"reference/modules/#packagescomponentsexespostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..postCheck"},{"location":"reference/modules/#packagescomponentsexespostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..postConfigure"},{"location":"reference/modules/#packagescomponentsexesposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..postHaddock"},{"location":"reference/modules/#packagescomponentsexespostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..postInstall"},{"location":"reference/modules/#packagescomponentsexespostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..postUnpack"},{"location":"reference/modules/#packagescomponentsexesprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..preBuild"},{"location":"reference/modules/#packagescomponentsexesprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..preCheck"},{"location":"reference/modules/#packagescomponentsexespreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..preConfigure"},{"location":"reference/modules/#packagescomponentsexesprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..preHaddock"},{"location":"reference/modules/#packagescomponentsexespreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.exes..preInstall"},{"location":"reference/modules/#packagescomponentsexespreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..components.exes..preUnpack"},{"location":"reference/modules/#packagescomponentsexesprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..components.exes..profilingDetail"},{"location":"reference/modules/#packagescomponentsexessetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.exes..setupBuildFlags"},{"location":"reference/modules/#packagescomponentsexessetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.exes..setupHaddockFlags"},{"location":"reference/modules/#packagescomponentsexessetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.exes..setupInstallFlags"},{"location":"reference/modules/#packagescomponentsexesshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..components.exes..shellHook"},{"location":"reference/modules/#packagescomponentsexestestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.exes..testFlags"},{"location":"reference/modules/#packagescomponentsexestestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..components.exes..testWrapper"},{"location":"reference/modules/#packagescomponentsforeignlibs","text":"This option has no description. Type : attribute set of submodules Default : {} No Example","title":"packages..components.foreignlibs"},{"location":"reference/modules/#packagescomponentsforeignlibsasmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..asmSources"},{"location":"reference/modules/#packagescomponentsforeignlibsbuild-tools","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..build-tools"},{"location":"reference/modules/#packagescomponentsforeignlibsbuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..buildable"},{"location":"reference/modules/#packagescomponentsforeignlibscsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..cSources"},{"location":"reference/modules/#packagescomponentsforeignlibscmmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..cmmSources"},{"location":"reference/modules/#packagescomponentsforeignlibsconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.foreignlibs..configureFlags"},{"location":"reference/modules/#packagescomponentsforeignlibscxxsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..cxxSources"},{"location":"reference/modules/#packagescomponentsforeignlibsdepends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..depends"},{"location":"reference/modules/#packagescomponentsforeignlibsdocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..doCheck"},{"location":"reference/modules/#packagescomponentsforeignlibsdocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..components.foreignlibs..doCoverage"},{"location":"reference/modules/#packagescomponentsforeignlibsdocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..components.foreignlibs..doCrossCheck"},{"location":"reference/modules/#packagescomponentsforeignlibsdoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.foreignlibs..doExactConfig"},{"location":"reference/modules/#packagescomponentsforeignlibsdohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..doHaddock"},{"location":"reference/modules/#packagescomponentsforeignlibsdohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..doHoogle"},{"location":"reference/modules/#packagescomponentsforeignlibsdohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..doHyperlinkSource"},{"location":"reference/modules/#packagescomponentsforeignlibsdoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..doQuickjump"},{"location":"reference/modules/#packagescomponentsforeignlibsdontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..dontPatchELF"},{"location":"reference/modules/#packagescomponentsforeignlibsdontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..dontStrip"},{"location":"reference/modules/#packagescomponentsforeignlibsenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..components.foreignlibs..enableDeadCodeElimination"},{"location":"reference/modules/#packagescomponentsforeignlibsenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.foreignlibs..enableExecutableProfiling"},{"location":"reference/modules/#packagescomponentsforeignlibsenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.foreignlibs..enableLibraryProfiling"},{"location":"reference/modules/#packagescomponentsforeignlibsenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.foreignlibs..enableSeparateDataOutput"},{"location":"reference/modules/#packagescomponentsforeignlibsenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..enableShared"},{"location":"reference/modules/#packagescomponentsforeignlibsenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..components.foreignlibs..enableStatic"},{"location":"reference/modules/#packagescomponentsforeignlibsextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..extraSrcFiles"},{"location":"reference/modules/#packagescomponentsforeignlibsframeworks","text":"This option has no description. Type : list of packages Default : [] No Example","title":"packages..components.foreignlibs..frameworks"},{"location":"reference/modules/#packagescomponentsforeignlibshardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.foreignlibs..hardeningDisable"},{"location":"reference/modules/#packagescomponentsforeignlibshssourcedirs","text":"This option has no description. Type : list of unspecifieds Default : [\".\"] No Example","title":"packages..components.foreignlibs..hsSourceDirs"},{"location":"reference/modules/#packagescomponentsforeignlibsincludedirs","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..includeDirs"},{"location":"reference/modules/#packagescomponentsforeignlibsincludes","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..includes"},{"location":"reference/modules/#packagescomponentsforeignlibsjssources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..jsSources"},{"location":"reference/modules/#packagescomponentsforeignlibskeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..components.foreignlibs..keepSource"},{"location":"reference/modules/#packagescomponentsforeignlibslibs","text":"This option has no description. Type : list of null or packages Default : [] No Example","title":"packages..components.foreignlibs..libs"},{"location":"reference/modules/#packagescomponentsforeignlibsmainpath","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..mainPath"},{"location":"reference/modules/#packagescomponentsforeignlibsmodules","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.foreignlibs..modules"},{"location":"reference/modules/#packagescomponentsforeignlibspkgconfig","text":"This option has no description. Type : list of list of packagess Default : [] No Example","title":"packages..components.foreignlibs..pkgconfig"},{"location":"reference/modules/#packagescomponentsforeignlibsplatforms","text":"This option has no description. Type : null or list of unspecifieds Default : null No Example","title":"packages..components.foreignlibs..platforms"},{"location":"reference/modules/#packagescomponentsforeignlibspostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..postBuild"},{"location":"reference/modules/#packagescomponentsforeignlibspostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..postCheck"},{"location":"reference/modules/#packagescomponentsforeignlibspostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..postConfigure"},{"location":"reference/modules/#packagescomponentsforeignlibsposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..postHaddock"},{"location":"reference/modules/#packagescomponentsforeignlibspostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..postInstall"},{"location":"reference/modules/#packagescomponentsforeignlibspostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..postUnpack"},{"location":"reference/modules/#packagescomponentsforeignlibsprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..preBuild"},{"location":"reference/modules/#packagescomponentsforeignlibsprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..preCheck"},{"location":"reference/modules/#packagescomponentsforeignlibspreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..preConfigure"},{"location":"reference/modules/#packagescomponentsforeignlibsprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..preHaddock"},{"location":"reference/modules/#packagescomponentsforeignlibspreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.foreignlibs..preInstall"},{"location":"reference/modules/#packagescomponentsforeignlibspreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..components.foreignlibs..preUnpack"},{"location":"reference/modules/#packagescomponentsforeignlibsprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..components.foreignlibs..profilingDetail"},{"location":"reference/modules/#packagescomponentsforeignlibssetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.foreignlibs..setupBuildFlags"},{"location":"reference/modules/#packagescomponentsforeignlibssetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.foreignlibs..setupHaddockFlags"},{"location":"reference/modules/#packagescomponentsforeignlibssetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.foreignlibs..setupInstallFlags"},{"location":"reference/modules/#packagescomponentsforeignlibsshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..components.foreignlibs..shellHook"},{"location":"reference/modules/#packagescomponentsforeignlibstestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.foreignlibs..testFlags"},{"location":"reference/modules/#packagescomponentsforeignlibstestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..components.foreignlibs..testWrapper"},{"location":"reference/modules/#packagescomponentslibrary","text":"This option has no description. Type : null or submodule Default : null No Example","title":"packages..components.library"},{"location":"reference/modules/#packagescomponentslibraryasmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.asmSources"},{"location":"reference/modules/#packagescomponentslibrarybuild-tools","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.build-tools"},{"location":"reference/modules/#packagescomponentslibrarybuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.library.buildable"},{"location":"reference/modules/#packagescomponentslibrarycsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.cSources"},{"location":"reference/modules/#packagescomponentslibrarycmmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.cmmSources"},{"location":"reference/modules/#packagescomponentslibraryconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.library.configureFlags"},{"location":"reference/modules/#packagescomponentslibrarycxxsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.cxxSources"},{"location":"reference/modules/#packagescomponentslibrarydepends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.depends"},{"location":"reference/modules/#packagescomponentslibrarydocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.library.doCheck"},{"location":"reference/modules/#packagescomponentslibrarydocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..components.library.doCoverage"},{"location":"reference/modules/#packagescomponentslibrarydocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..components.library.doCrossCheck"},{"location":"reference/modules/#packagescomponentslibrarydoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.library.doExactConfig"},{"location":"reference/modules/#packagescomponentslibrarydohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..components.library.doHaddock"},{"location":"reference/modules/#packagescomponentslibrarydohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..components.library.doHoogle"},{"location":"reference/modules/#packagescomponentslibrarydohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..components.library.doHyperlinkSource"},{"location":"reference/modules/#packagescomponentslibrarydoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..components.library.doQuickjump"},{"location":"reference/modules/#packagescomponentslibrarydontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..components.library.dontPatchELF"},{"location":"reference/modules/#packagescomponentslibrarydontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..components.library.dontStrip"},{"location":"reference/modules/#packagescomponentslibraryenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..components.library.enableDeadCodeElimination"},{"location":"reference/modules/#packagescomponentslibraryenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.library.enableExecutableProfiling"},{"location":"reference/modules/#packagescomponentslibraryenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.library.enableLibraryProfiling"},{"location":"reference/modules/#packagescomponentslibraryenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.library.enableSeparateDataOutput"},{"location":"reference/modules/#packagescomponentslibraryenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..components.library.enableShared"},{"location":"reference/modules/#packagescomponentslibraryenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..components.library.enableStatic"},{"location":"reference/modules/#packagescomponentslibraryextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.extraSrcFiles"},{"location":"reference/modules/#packagescomponentslibraryframeworks","text":"This option has no description. Type : list of packages Default : [] No Example","title":"packages..components.library.frameworks"},{"location":"reference/modules/#packagescomponentslibraryhardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.library.hardeningDisable"},{"location":"reference/modules/#packagescomponentslibraryhssourcedirs","text":"This option has no description. Type : list of unspecifieds Default : [\".\"] No Example","title":"packages..components.library.hsSourceDirs"},{"location":"reference/modules/#packagescomponentslibraryincludedirs","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.includeDirs"},{"location":"reference/modules/#packagescomponentslibraryincludes","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.includes"},{"location":"reference/modules/#packagescomponentslibraryjssources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.jsSources"},{"location":"reference/modules/#packagescomponentslibrarykeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..components.library.keepSource"},{"location":"reference/modules/#packagescomponentslibrarylibs","text":"This option has no description. Type : list of null or packages Default : [] No Example","title":"packages..components.library.libs"},{"location":"reference/modules/#packagescomponentslibrarymainpath","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.mainPath"},{"location":"reference/modules/#packagescomponentslibrarymodules","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.library.modules"},{"location":"reference/modules/#packagescomponentslibrarypkgconfig","text":"This option has no description. Type : list of list of packagess Default : [] No Example","title":"packages..components.library.pkgconfig"},{"location":"reference/modules/#packagescomponentslibraryplatforms","text":"This option has no description. Type : null or list of unspecifieds Default : null No Example","title":"packages..components.library.platforms"},{"location":"reference/modules/#packagescomponentslibrarypostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.postBuild"},{"location":"reference/modules/#packagescomponentslibrarypostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.postCheck"},{"location":"reference/modules/#packagescomponentslibrarypostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.postConfigure"},{"location":"reference/modules/#packagescomponentslibraryposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.postHaddock"},{"location":"reference/modules/#packagescomponentslibrarypostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.postInstall"},{"location":"reference/modules/#packagescomponentslibrarypostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.postUnpack"},{"location":"reference/modules/#packagescomponentslibraryprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.preBuild"},{"location":"reference/modules/#packagescomponentslibraryprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.preCheck"},{"location":"reference/modules/#packagescomponentslibrarypreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.preConfigure"},{"location":"reference/modules/#packagescomponentslibraryprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.preHaddock"},{"location":"reference/modules/#packagescomponentslibrarypreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.library.preInstall"},{"location":"reference/modules/#packagescomponentslibrarypreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..components.library.preUnpack"},{"location":"reference/modules/#packagescomponentslibraryprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..components.library.profilingDetail"},{"location":"reference/modules/#packagescomponentslibrarysetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.library.setupBuildFlags"},{"location":"reference/modules/#packagescomponentslibrarysetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.library.setupHaddockFlags"},{"location":"reference/modules/#packagescomponentslibrarysetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.library.setupInstallFlags"},{"location":"reference/modules/#packagescomponentslibraryshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..components.library.shellHook"},{"location":"reference/modules/#packagescomponentslibrarytestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.library.testFlags"},{"location":"reference/modules/#packagescomponentslibrarytestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..components.library.testWrapper"},{"location":"reference/modules/#packagescomponentssetup","text":"This option has no description. Type : null or submodule Default : {\"asmSources\":[],\"cSources\":[],\"cmmSources\":[],\"cxxSources\":[],\"depends\":[],\"doExactConfig\":false,\"extraSrcFiles\":[\"Setup.hs\",\"Setup.lhs\"],\"frameworks\":[],\"hsSourceDirs\":[\"setup-src\"],\"includeDirs\":[],\"jsSources\":[],\"libs\":[],\"platforms\":null} No Example","title":"packages..components.setup"},{"location":"reference/modules/#packagescomponentssetupasmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.asmSources"},{"location":"reference/modules/#packagescomponentssetupbuild-tools","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.build-tools"},{"location":"reference/modules/#packagescomponentssetupbuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.setup.buildable"},{"location":"reference/modules/#packagescomponentssetupcsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.cSources"},{"location":"reference/modules/#packagescomponentssetupcmmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.cmmSources"},{"location":"reference/modules/#packagescomponentssetupconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.setup.configureFlags"},{"location":"reference/modules/#packagescomponentssetupcxxsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.cxxSources"},{"location":"reference/modules/#packagescomponentssetupdepends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.depends"},{"location":"reference/modules/#packagescomponentssetupdocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.setup.doCheck"},{"location":"reference/modules/#packagescomponentssetupdocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..components.setup.doCoverage"},{"location":"reference/modules/#packagescomponentssetupdocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..components.setup.doCrossCheck"},{"location":"reference/modules/#packagescomponentssetupdoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.setup.doExactConfig"},{"location":"reference/modules/#packagescomponentssetupdohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..components.setup.doHaddock"},{"location":"reference/modules/#packagescomponentssetupdohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..components.setup.doHoogle"},{"location":"reference/modules/#packagescomponentssetupdohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..components.setup.doHyperlinkSource"},{"location":"reference/modules/#packagescomponentssetupdoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..components.setup.doQuickjump"},{"location":"reference/modules/#packagescomponentssetupdontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..components.setup.dontPatchELF"},{"location":"reference/modules/#packagescomponentssetupdontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..components.setup.dontStrip"},{"location":"reference/modules/#packagescomponentssetupenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..components.setup.enableDeadCodeElimination"},{"location":"reference/modules/#packagescomponentssetupenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.setup.enableExecutableProfiling"},{"location":"reference/modules/#packagescomponentssetupenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.setup.enableLibraryProfiling"},{"location":"reference/modules/#packagescomponentssetupenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.setup.enableSeparateDataOutput"},{"location":"reference/modules/#packagescomponentssetupenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..components.setup.enableShared"},{"location":"reference/modules/#packagescomponentssetupenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..components.setup.enableStatic"},{"location":"reference/modules/#packagescomponentssetupextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.extraSrcFiles"},{"location":"reference/modules/#packagescomponentssetupframeworks","text":"This option has no description. Type : list of packages Default : [] No Example","title":"packages..components.setup.frameworks"},{"location":"reference/modules/#packagescomponentssetuphardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.setup.hardeningDisable"},{"location":"reference/modules/#packagescomponentssetuphssourcedirs","text":"This option has no description. Type : list of unspecifieds Default : [\".\"] No Example","title":"packages..components.setup.hsSourceDirs"},{"location":"reference/modules/#packagescomponentssetupincludedirs","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.includeDirs"},{"location":"reference/modules/#packagescomponentssetupincludes","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.includes"},{"location":"reference/modules/#packagescomponentssetupjssources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.jsSources"},{"location":"reference/modules/#packagescomponentssetupkeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..components.setup.keepSource"},{"location":"reference/modules/#packagescomponentssetuplibs","text":"This option has no description. Type : list of null or packages Default : [] No Example","title":"packages..components.setup.libs"},{"location":"reference/modules/#packagescomponentssetupmainpath","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.mainPath"},{"location":"reference/modules/#packagescomponentssetupmodules","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.setup.modules"},{"location":"reference/modules/#packagescomponentssetuppkgconfig","text":"This option has no description. Type : list of list of packagess Default : [] No Example","title":"packages..components.setup.pkgconfig"},{"location":"reference/modules/#packagescomponentssetupplatforms","text":"This option has no description. Type : null or list of unspecifieds Default : null No Example","title":"packages..components.setup.platforms"},{"location":"reference/modules/#packagescomponentssetuppostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.postBuild"},{"location":"reference/modules/#packagescomponentssetuppostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.postCheck"},{"location":"reference/modules/#packagescomponentssetuppostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.postConfigure"},{"location":"reference/modules/#packagescomponentssetupposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.postHaddock"},{"location":"reference/modules/#packagescomponentssetuppostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.postInstall"},{"location":"reference/modules/#packagescomponentssetuppostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.postUnpack"},{"location":"reference/modules/#packagescomponentssetupprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.preBuild"},{"location":"reference/modules/#packagescomponentssetupprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.preCheck"},{"location":"reference/modules/#packagescomponentssetuppreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.preConfigure"},{"location":"reference/modules/#packagescomponentssetupprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.preHaddock"},{"location":"reference/modules/#packagescomponentssetuppreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.setup.preInstall"},{"location":"reference/modules/#packagescomponentssetuppreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..components.setup.preUnpack"},{"location":"reference/modules/#packagescomponentssetupprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..components.setup.profilingDetail"},{"location":"reference/modules/#packagescomponentssetupsetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.setup.setupBuildFlags"},{"location":"reference/modules/#packagescomponentssetupsetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.setup.setupHaddockFlags"},{"location":"reference/modules/#packagescomponentssetupsetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.setup.setupInstallFlags"},{"location":"reference/modules/#packagescomponentssetupshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..components.setup.shellHook"},{"location":"reference/modules/#packagescomponentssetuptestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.setup.testFlags"},{"location":"reference/modules/#packagescomponentssetuptestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..components.setup.testWrapper"},{"location":"reference/modules/#packagescomponentssublibs","text":"This option has no description. Type : attribute set of submodules Default : {} No Example","title":"packages..components.sublibs"},{"location":"reference/modules/#packagescomponentssublibsasmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..asmSources"},{"location":"reference/modules/#packagescomponentssublibsbuild-tools","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..build-tools"},{"location":"reference/modules/#packagescomponentssublibsbuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.sublibs..buildable"},{"location":"reference/modules/#packagescomponentssublibscsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..cSources"},{"location":"reference/modules/#packagescomponentssublibscmmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..cmmSources"},{"location":"reference/modules/#packagescomponentssublibsconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.sublibs..configureFlags"},{"location":"reference/modules/#packagescomponentssublibscxxsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..cxxSources"},{"location":"reference/modules/#packagescomponentssublibsdepends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..depends"},{"location":"reference/modules/#packagescomponentssublibsdocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.sublibs..doCheck"},{"location":"reference/modules/#packagescomponentssublibsdocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..components.sublibs..doCoverage"},{"location":"reference/modules/#packagescomponentssublibsdocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..components.sublibs..doCrossCheck"},{"location":"reference/modules/#packagescomponentssublibsdoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.sublibs..doExactConfig"},{"location":"reference/modules/#packagescomponentssublibsdohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..components.sublibs..doHaddock"},{"location":"reference/modules/#packagescomponentssublibsdohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..components.sublibs..doHoogle"},{"location":"reference/modules/#packagescomponentssublibsdohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..components.sublibs..doHyperlinkSource"},{"location":"reference/modules/#packagescomponentssublibsdoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..components.sublibs..doQuickjump"},{"location":"reference/modules/#packagescomponentssublibsdontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..components.sublibs..dontPatchELF"},{"location":"reference/modules/#packagescomponentssublibsdontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..components.sublibs..dontStrip"},{"location":"reference/modules/#packagescomponentssublibsenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..components.sublibs..enableDeadCodeElimination"},{"location":"reference/modules/#packagescomponentssublibsenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.sublibs..enableExecutableProfiling"},{"location":"reference/modules/#packagescomponentssublibsenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.sublibs..enableLibraryProfiling"},{"location":"reference/modules/#packagescomponentssublibsenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.sublibs..enableSeparateDataOutput"},{"location":"reference/modules/#packagescomponentssublibsenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..components.sublibs..enableShared"},{"location":"reference/modules/#packagescomponentssublibsenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..components.sublibs..enableStatic"},{"location":"reference/modules/#packagescomponentssublibsextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..extraSrcFiles"},{"location":"reference/modules/#packagescomponentssublibsframeworks","text":"This option has no description. Type : list of packages Default : [] No Example","title":"packages..components.sublibs..frameworks"},{"location":"reference/modules/#packagescomponentssublibshardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.sublibs..hardeningDisable"},{"location":"reference/modules/#packagescomponentssublibshssourcedirs","text":"This option has no description. Type : list of unspecifieds Default : [\".\"] No Example","title":"packages..components.sublibs..hsSourceDirs"},{"location":"reference/modules/#packagescomponentssublibsincludedirs","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..includeDirs"},{"location":"reference/modules/#packagescomponentssublibsincludes","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..includes"},{"location":"reference/modules/#packagescomponentssublibsjssources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..jsSources"},{"location":"reference/modules/#packagescomponentssublibskeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..components.sublibs..keepSource"},{"location":"reference/modules/#packagescomponentssublibslibs","text":"This option has no description. Type : list of null or packages Default : [] No Example","title":"packages..components.sublibs..libs"},{"location":"reference/modules/#packagescomponentssublibsmainpath","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..mainPath"},{"location":"reference/modules/#packagescomponentssublibsmodules","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.sublibs..modules"},{"location":"reference/modules/#packagescomponentssublibspkgconfig","text":"This option has no description. Type : list of list of packagess Default : [] No Example","title":"packages..components.sublibs..pkgconfig"},{"location":"reference/modules/#packagescomponentssublibsplatforms","text":"This option has no description. Type : null or list of unspecifieds Default : null No Example","title":"packages..components.sublibs..platforms"},{"location":"reference/modules/#packagescomponentssublibspostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..postBuild"},{"location":"reference/modules/#packagescomponentssublibspostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..postCheck"},{"location":"reference/modules/#packagescomponentssublibspostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..postConfigure"},{"location":"reference/modules/#packagescomponentssublibsposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..postHaddock"},{"location":"reference/modules/#packagescomponentssublibspostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..postInstall"},{"location":"reference/modules/#packagescomponentssublibspostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..postUnpack"},{"location":"reference/modules/#packagescomponentssublibsprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..preBuild"},{"location":"reference/modules/#packagescomponentssublibsprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..preCheck"},{"location":"reference/modules/#packagescomponentssublibspreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..preConfigure"},{"location":"reference/modules/#packagescomponentssublibsprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..preHaddock"},{"location":"reference/modules/#packagescomponentssublibspreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.sublibs..preInstall"},{"location":"reference/modules/#packagescomponentssublibspreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..components.sublibs..preUnpack"},{"location":"reference/modules/#packagescomponentssublibsprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..components.sublibs..profilingDetail"},{"location":"reference/modules/#packagescomponentssublibssetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.sublibs..setupBuildFlags"},{"location":"reference/modules/#packagescomponentssublibssetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.sublibs..setupHaddockFlags"},{"location":"reference/modules/#packagescomponentssublibssetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.sublibs..setupInstallFlags"},{"location":"reference/modules/#packagescomponentssublibsshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..components.sublibs..shellHook"},{"location":"reference/modules/#packagescomponentssublibstestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.sublibs..testFlags"},{"location":"reference/modules/#packagescomponentssublibstestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..components.sublibs..testWrapper"},{"location":"reference/modules/#packagescomponentstests","text":"This option has no description. Type : attribute set of submodules Default : {} No Example","title":"packages..components.tests"},{"location":"reference/modules/#packagescomponentstestsasmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..asmSources"},{"location":"reference/modules/#packagescomponentstestsbuild-tools","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..build-tools"},{"location":"reference/modules/#packagescomponentstestsbuildable","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.tests..buildable"},{"location":"reference/modules/#packagescomponentstestscsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..cSources"},{"location":"reference/modules/#packagescomponentstestscmmsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..cmmSources"},{"location":"reference/modules/#packagescomponentstestsconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.tests..configureFlags"},{"location":"reference/modules/#packagescomponentstestscxxsources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..cxxSources"},{"location":"reference/modules/#packagescomponentstestsdepends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..depends"},{"location":"reference/modules/#packagescomponentstestsdocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..components.tests..doCheck"},{"location":"reference/modules/#packagescomponentstestsdocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..components.tests..doCoverage"},{"location":"reference/modules/#packagescomponentstestsdocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..components.tests..doCrossCheck"},{"location":"reference/modules/#packagescomponentstestsdoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.tests..doExactConfig"},{"location":"reference/modules/#packagescomponentstestsdohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..components.tests..doHaddock"},{"location":"reference/modules/#packagescomponentstestsdohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..components.tests..doHoogle"},{"location":"reference/modules/#packagescomponentstestsdohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..components.tests..doHyperlinkSource"},{"location":"reference/modules/#packagescomponentstestsdoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..components.tests..doQuickjump"},{"location":"reference/modules/#packagescomponentstestsdontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..components.tests..dontPatchELF"},{"location":"reference/modules/#packagescomponentstestsdontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..components.tests..dontStrip"},{"location":"reference/modules/#packagescomponentstestsenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..components.tests..enableDeadCodeElimination"},{"location":"reference/modules/#packagescomponentstestsenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.tests..enableExecutableProfiling"},{"location":"reference/modules/#packagescomponentstestsenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.tests..enableLibraryProfiling"},{"location":"reference/modules/#packagescomponentstestsenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..components.tests..enableSeparateDataOutput"},{"location":"reference/modules/#packagescomponentstestsenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..components.tests..enableShared"},{"location":"reference/modules/#packagescomponentstestsenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..components.tests..enableStatic"},{"location":"reference/modules/#packagescomponentstestsextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..extraSrcFiles"},{"location":"reference/modules/#packagescomponentstestsframeworks","text":"This option has no description. Type : list of packages Default : [] No Example","title":"packages..components.tests..frameworks"},{"location":"reference/modules/#packagescomponentstestshardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.tests..hardeningDisable"},{"location":"reference/modules/#packagescomponentstestshssourcedirs","text":"This option has no description. Type : list of unspecifieds Default : [\".\"] No Example","title":"packages..components.tests..hsSourceDirs"},{"location":"reference/modules/#packagescomponentstestsincludedirs","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..includeDirs"},{"location":"reference/modules/#packagescomponentstestsincludes","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..includes"},{"location":"reference/modules/#packagescomponentstestsjssources","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..jsSources"},{"location":"reference/modules/#packagescomponentstestskeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..components.tests..keepSource"},{"location":"reference/modules/#packagescomponentstestslibs","text":"This option has no description. Type : list of null or packages Default : [] No Example","title":"packages..components.tests..libs"},{"location":"reference/modules/#packagescomponentstestsmainpath","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..mainPath"},{"location":"reference/modules/#packagescomponentstestsmodules","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..components.tests..modules"},{"location":"reference/modules/#packagescomponentstestspkgconfig","text":"This option has no description. Type : list of list of packagess Default : [] No Example","title":"packages..components.tests..pkgconfig"},{"location":"reference/modules/#packagescomponentstestsplatforms","text":"This option has no description. Type : null or list of unspecifieds Default : null No Example","title":"packages..components.tests..platforms"},{"location":"reference/modules/#packagescomponentstestspostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..postBuild"},{"location":"reference/modules/#packagescomponentstestspostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..postCheck"},{"location":"reference/modules/#packagescomponentstestspostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..postConfigure"},{"location":"reference/modules/#packagescomponentstestsposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..postHaddock"},{"location":"reference/modules/#packagescomponentstestspostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..postInstall"},{"location":"reference/modules/#packagescomponentstestspostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..postUnpack"},{"location":"reference/modules/#packagescomponentstestsprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..preBuild"},{"location":"reference/modules/#packagescomponentstestsprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..preCheck"},{"location":"reference/modules/#packagescomponentstestspreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..preConfigure"},{"location":"reference/modules/#packagescomponentstestsprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..preHaddock"},{"location":"reference/modules/#packagescomponentstestspreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..components.tests..preInstall"},{"location":"reference/modules/#packagescomponentstestspreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..components.tests..preUnpack"},{"location":"reference/modules/#packagescomponentstestsprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..components.tests..profilingDetail"},{"location":"reference/modules/#packagescomponentstestssetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.tests..setupBuildFlags"},{"location":"reference/modules/#packagescomponentstestssetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.tests..setupHaddockFlags"},{"location":"reference/modules/#packagescomponentstestssetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.tests..setupInstallFlags"},{"location":"reference/modules/#packagescomponentstestsshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..components.tests..shellHook"},{"location":"reference/modules/#packagescomponentsteststestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..components.tests..testFlags"},{"location":"reference/modules/#packagescomponentsteststestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..components.tests..testWrapper"},{"location":"reference/modules/#packagesconfigureflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..configureFlags"},{"location":"reference/modules/#packagesdocheck","text":"This option has no description. Type : boolean Default : true No Example","title":"packages..doCheck"},{"location":"reference/modules/#packagesdocoverage","text":"Enable production of test coverage reports. Type : boolean Default : false No Example","title":"packages..doCoverage"},{"location":"reference/modules/#packagesdocrosscheck","text":"Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type : boolean Default : false No Example","title":"packages..doCrossCheck"},{"location":"reference/modules/#packagesdoexactconfig","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..doExactConfig"},{"location":"reference/modules/#packagesdohaddock","text":"Enable building of the Haddock documentation from the annotated Haskell source code. Type : boolean Default : true No Example","title":"packages..doHaddock"},{"location":"reference/modules/#packagesdohoogle","text":"Also build a hoogle index. Type : boolean Default : true No Example","title":"packages..doHoogle"},{"location":"reference/modules/#packagesdohyperlinksource","text":"Link documentation to the source code. Type : boolean Default : true No Example","title":"packages..doHyperlinkSource"},{"location":"reference/modules/#packagesdoquickjump","text":"Generate an index for interactive documentation navigation. Type : boolean Default : true No Example","title":"packages..doQuickjump"},{"location":"reference/modules/#packagesdontpatchelf","text":"If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux. Type : boolean Default : true No Example","title":"packages..dontPatchELF"},{"location":"reference/modules/#packagesdontstrip","text":"If set, libraries and executables are not stripped. Type : boolean Default : true No Example","title":"packages..dontStrip"},{"location":"reference/modules/#packagesenabledeadcodeelimination","text":"If set, enables split sections for link-time dead-code stripping. Only applies to Linux Type : boolean Default : true No Example","title":"packages..enableDeadCodeElimination"},{"location":"reference/modules/#packagesenableexecutableprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..enableExecutableProfiling"},{"location":"reference/modules/#packagesenablelibraryprofiling","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..enableLibraryProfiling"},{"location":"reference/modules/#packagesenableseparatedataoutput","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..enableSeparateDataOutput"},{"location":"reference/modules/#packagesenableshared","text":"If set, enables building shared libraries. Type : boolean Default : true No Example","title":"packages..enableShared"},{"location":"reference/modules/#packagesenablestatic","text":"If set, enables building static libraries and executables. Type : boolean Default : true No Example","title":"packages..enableStatic"},{"location":"reference/modules/#packagesflags","text":"This option has no description. Type : attribute set of booleans No Default No Example","title":"packages..flags"},{"location":"reference/modules/#packageshardeningdisable","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..hardeningDisable"},{"location":"reference/modules/#packageskeepsource","text":"Keep component source in the store in a source output Type : boolean Default : false No Example","title":"packages..keepSource"},{"location":"reference/modules/#packagesname","text":"This option has no description. Type : string Default : \"${config.package.identifier.name}-${config.package.identifier.version}\" No Example","title":"packages..name"},{"location":"reference/modules/#packagespackageauthor","text":"This option has no description. Type : string No Default No Example","title":"packages..package.author"},{"location":"reference/modules/#packagespackagebuildtype","text":"This option has no description. Type : string No Default No Example","title":"packages..package.buildType"},{"location":"reference/modules/#packagespackagecleanhpack","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..package.cleanHpack"},{"location":"reference/modules/#packagespackagecopyright","text":"This option has no description. Type : string No Default No Example","title":"packages..package.copyright"},{"location":"reference/modules/#packagespackagedatadir","text":"This option has no description. Type : string Default : \"\" No Example","title":"packages..package.dataDir"},{"location":"reference/modules/#packagespackagedatafiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..package.dataFiles"},{"location":"reference/modules/#packagespackagedescription","text":"This option has no description. Type : string No Default No Example","title":"packages..package.description"},{"location":"reference/modules/#packagespackagedetaillevel","text":"This option has no description. Type : string Default : \"MinimalDetails\" No Example","title":"packages..package.detailLevel"},{"location":"reference/modules/#packagespackageextradocfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..package.extraDocFiles"},{"location":"reference/modules/#packagespackageextrasrcfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..package.extraSrcFiles"},{"location":"reference/modules/#packagespackageextratmpfiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..package.extraTmpFiles"},{"location":"reference/modules/#packagespackageghcoptions","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..package.ghcOptions"},{"location":"reference/modules/#packagespackagehomepage","text":"This option has no description. Type : string No Default No Example","title":"packages..package.homepage"},{"location":"reference/modules/#packagespackageidentifiername","text":"This option has no description. Type : string No Default No Example","title":"packages..package.identifier.name"},{"location":"reference/modules/#packagespackageidentifierversion","text":"This option has no description. Type : string No Default No Example","title":"packages..package.identifier.version"},{"location":"reference/modules/#packagespackageislocal","text":"This option has no description. Type : boolean Default : false No Example","title":"packages..package.isLocal"},{"location":"reference/modules/#packagespackagelicense","text":"This option has no description. Type : string No Default No Example","title":"packages..package.license"},{"location":"reference/modules/#packagespackagelicensefiles","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..package.licenseFiles"},{"location":"reference/modules/#packagespackagemaintainer","text":"This option has no description. Type : string No Default No Example","title":"packages..package.maintainer"},{"location":"reference/modules/#packagespackagesetup-depends","text":"This option has no description. Type : list of unspecifieds Default : [] No Example","title":"packages..package.setup-depends"},{"location":"reference/modules/#packagespackagespecversion","text":"This option has no description. Type : string No Default No Example","title":"packages..package.specVersion"},{"location":"reference/modules/#packagespackagesynopsis","text":"This option has no description. Type : string No Default No Example","title":"packages..package.synopsis"},{"location":"reference/modules/#packagespackageurl","text":"This option has no description. Type : string No Default No Example","title":"packages..package.url"},{"location":"reference/modules/#packagespatches","text":"This option has no description. Type : list of unspecified or paths Default : [] No Example","title":"packages..patches"},{"location":"reference/modules/#packagespostbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..postBuild"},{"location":"reference/modules/#packagespostcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..postCheck"},{"location":"reference/modules/#packagespostconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..postConfigure"},{"location":"reference/modules/#packagesposthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..postHaddock"},{"location":"reference/modules/#packagespostinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..postInstall"},{"location":"reference/modules/#packagespostunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..postUnpack"},{"location":"reference/modules/#packagesprebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..preBuild"},{"location":"reference/modules/#packagesprecheck","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..preCheck"},{"location":"reference/modules/#packagespreconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..preConfigure"},{"location":"reference/modules/#packagesprehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..preHaddock"},{"location":"reference/modules/#packagespreinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..preInstall"},{"location":"reference/modules/#packagespreunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"packages..preUnpack"},{"location":"reference/modules/#packagesprofilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"packages..profilingDetail"},{"location":"reference/modules/#packagesrevision","text":"This option has no description. Type : null or signed integer Default : null No Example","title":"packages..revision"},{"location":"reference/modules/#packagesrevisionsha256","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..revisionSha256"},{"location":"reference/modules/#packagessetupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..setupBuildFlags"},{"location":"reference/modules/#packagessetuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..setupHaddockFlags"},{"location":"reference/modules/#packagessetupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..setupInstallFlags"},{"location":"reference/modules/#packagessha256","text":"This option has no description. Type : null or string Default : null No Example","title":"packages..sha256"},{"location":"reference/modules/#packagesshellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"packages..shellHook"},{"location":"reference/modules/#packagessrc","text":"This option has no description. Type : path or package Default : \"pkgs.fetchurl { url = \\\"mirror://hackage/${config.name}.tar.gz\\\"; inherit (config) sha256; };\" No Example","title":"packages..src"},{"location":"reference/modules/#packagestestflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"packages..testFlags"},{"location":"reference/modules/#packagestestwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"packages..testWrapper"},{"location":"reference/modules/#postbuild","text":"This option has no description. Type : null or string Default : null No Example","title":"postBuild"},{"location":"reference/modules/#postcheck","text":"This option has no description. Type : null or string Default : null No Example","title":"postCheck"},{"location":"reference/modules/#postconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"postConfigure"},{"location":"reference/modules/#posthaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"postHaddock"},{"location":"reference/modules/#postinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"postInstall"},{"location":"reference/modules/#postunpack","text":"This option has no description. Type : null or string Default : null No Example","title":"postUnpack"},{"location":"reference/modules/#prebuild","text":"This option has no description. Type : null or string Default : null No Example","title":"preBuild"},{"location":"reference/modules/#precheck","text":"This option has no description. Type : null or string Default : null No Example","title":"preCheck"},{"location":"reference/modules/#preconfigure","text":"This option has no description. Type : null or string Default : null No Example","title":"preConfigure"},{"location":"reference/modules/#prehaddock","text":"This option has no description. Type : null or string Default : null No Example","title":"preHaddock"},{"location":"reference/modules/#preinstall","text":"This option has no description. Type : null or string Default : null No Example","title":"preInstall"},{"location":"reference/modules/#preunpack","text":"This option has no description. Type : null or strings concatenated with \"\\n\" Default : null No Example","title":"preUnpack"},{"location":"reference/modules/#profilingdetail","text":"This option has no description. Type : null or string Default : \"default\" No Example","title":"profilingDetail"},{"location":"reference/modules/#reinstallablelibghc","text":"Is lib:ghc reinstallable? Type : boolean Default : false No Example","title":"reinstallableLibGhc"},{"location":"reference/modules/#setup-depends","text":"pkgs to globally provide to Setup.hs builds Type : list of unspecifieds Default : [] No Example","title":"setup-depends"},{"location":"reference/modules/#setupbuildflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"setupBuildFlags"},{"location":"reference/modules/#setuphaddockflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"setupHaddockFlags"},{"location":"reference/modules/#setupinstallflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"setupInstallFlags"},{"location":"reference/modules/#shellhook","text":"Hook to run when entering a shell Type : unspecified Default : \"\" No Example","title":"shellHook"},{"location":"reference/modules/#testflags","text":"This option has no description. Type : list of strings Default : [] No Example","title":"testFlags"},{"location":"reference/modules/#testwrapper","text":"A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type : list of strings Default : [] Example : \"echo\"","title":"testWrapper"},{"location":"reference/supported-ghc-versions/","text":"Supported GHC Versions \u00b6 The following versions of GHC built on the CI servers and should be included in the cache (for the default haskell.nix nixpkgs ). 8.6.5 compiler-nix-name = \"ghc865\"; 8.8.3 compiler-nix-name = \"ghc883\"; 8.8.4 compiler-nix-name = \"ghc884\"; 8.10.1 compiler-nix-name = \"ghc8101\"; 8.10.2 compiler-nix-name = \"ghc8102\"; Full test suite is run against 8.6.5, 8.8.4 and 8.10.2. See ci.nix for the list of tested GHC versions. The following GHC versions are not included in CI and will not be cached: 8.4.4 compiler-nix-name = \"ghc844\"; 8.6.1 compiler-nix-name = \"ghc861\"; 8.6.2 compiler-nix-name = \"ghc862\"; 8.6.3 compiler-nix-name = \"ghc863\"; 8.6.4 compiler-nix-name = \"ghc864\"; 8.8.1 compiler-nix-name = \"ghc881\"; 8.8.2 compiler-nix-name = \"ghc882\"; See overlays/bootstrap.nix for a list of all the valid compiler-nix-names . See also: Instructions on adding new ghc versions .","title":"Suported GHC versions"},{"location":"reference/supported-ghc-versions/#supported-ghc-versions","text":"The following versions of GHC built on the CI servers and should be included in the cache (for the default haskell.nix nixpkgs ). 8.6.5 compiler-nix-name = \"ghc865\"; 8.8.3 compiler-nix-name = \"ghc883\"; 8.8.4 compiler-nix-name = \"ghc884\"; 8.10.1 compiler-nix-name = \"ghc8101\"; 8.10.2 compiler-nix-name = \"ghc8102\"; Full test suite is run against 8.6.5, 8.8.4 and 8.10.2. See ci.nix for the list of tested GHC versions. The following GHC versions are not included in CI and will not be cached: 8.4.4 compiler-nix-name = \"ghc844\"; 8.6.1 compiler-nix-name = \"ghc861\"; 8.6.2 compiler-nix-name = \"ghc862\"; 8.6.3 compiler-nix-name = \"ghc863\"; 8.6.4 compiler-nix-name = \"ghc864\"; 8.8.1 compiler-nix-name = \"ghc881\"; 8.8.2 compiler-nix-name = \"ghc882\"; See overlays/bootstrap.nix for a list of all the valid compiler-nix-names . See also: Instructions on adding new ghc versions .","title":"Supported GHC Versions"},{"location":"tutorials/building-package-from-stackage-hackage/","text":"Build a specific package from Hackage or Stackage \u00b6 From a Stackage snapshot \u00b6 To build a package, say lens , from a Stackage snapshot, say lts-13.28 , you could run: nix build '(with import <nixpkgs> (import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {}).nixpkgsArgs; haskell-nix.snapshots.\"lts-13.28\").lens.components.library' This would build the (public) library component of the lens package as fixed by the lts-13.28 stackage snapshot. Nightly snapshots like nightly-2020-06-21 are also available. A specific version from Hackage \u00b6 To build any package from hackage, say lens , at any version, say 4.17.1, you could run: nix build '(with import <nixpkgs> (import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; compiler-nix-name = \"ghc8102\"; })).components.library' This would build the (public) library component of the lens-4.17.1 package from hackage. Pinning hackage index \u00b6 The dependencies would be resolved against the most recent hackage-index-state which comes with your haskell.nix checkout via the hackage.nix pin. A specific one can be specified as well: nix build '(with import <nixpkgs> (import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; compiler-nix-name = \"ghc8102\"; index-state = \"2019-07-14T00:00:00Z\"; })).components.library' This would use the hackage index as of 2019-07-14T00:00:00Z to produce a build plan for the lens-4.17.1 package.","title":"Build a specific package from Hackage or Stackage"},{"location":"tutorials/building-package-from-stackage-hackage/#build-a-specific-package-from-hackage-or-stackage","text":"","title":"Build a specific package from Hackage or Stackage"},{"location":"tutorials/building-package-from-stackage-hackage/#from-a-stackage-snapshot","text":"To build a package, say lens , from a Stackage snapshot, say lts-13.28 , you could run: nix build '(with import <nixpkgs> (import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {}).nixpkgsArgs; haskell-nix.snapshots.\"lts-13.28\").lens.components.library' This would build the (public) library component of the lens package as fixed by the lts-13.28 stackage snapshot. Nightly snapshots like nightly-2020-06-21 are also available.","title":"From a Stackage snapshot"},{"location":"tutorials/building-package-from-stackage-hackage/#a-specific-version-from-hackage","text":"To build any package from hackage, say lens , at any version, say 4.17.1, you could run: nix build '(with import <nixpkgs> (import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; compiler-nix-name = \"ghc8102\"; })).components.library' This would build the (public) library component of the lens-4.17.1 package from hackage.","title":"A specific version from Hackage"},{"location":"tutorials/building-package-from-stackage-hackage/#pinning-hackage-index","text":"The dependencies would be resolved against the most recent hackage-index-state which comes with your haskell.nix checkout via the hackage.nix pin. A specific one can be specified as well: nix build '(with import <nixpkgs> (import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {}).nixpkgsArgs; (haskell-nix.hackage-package { name = \"lens\"; version = \"4.17.1\"; compiler-nix-name = \"ghc8102\"; index-state = \"2019-07-14T00:00:00Z\"; })).components.library' This would use the hackage index as of 2019-07-14T00:00:00Z to produce a build plan for the lens-4.17.1 package.","title":"Pinning hackage index"},{"location":"tutorials/clean-git/","text":"cleanGit \u00b6 To filter out just the files in your git index use haskell-nix.haskellLib.cleanGit { src = ./.; } where ./. is the root of your git repo (or a git work tree). First it filters just the files needed to run git index , then it uses the results of that to filter your directory. It does not need to parse the .gitignore files at all, but we do need to git add our files before they will be included. cleanGit source . In addition haskell.nix (including cleanGit ) uses a version of cleanSourceWith with a subdir argument to filter out just the package it is building. Then it uses the info from the cabal file to filter just the source dirs for the component it is building. That way if we modify a test in a package nix will not rebuild the library in that package (or anything that depends on that package's library). There is a downside to this though. If we have a test that depends on something outside the scope of what is described in its entry in the in the .cabal file it will not see it. For instance perhaps it needs to run hlint or doctest on the library source. There are ways to fix this with a module: Use extraSrcFiles to add dirs the test needs (this will not result in a change to the .cabal file the test will still be built the same). components.tests.test.extraSrcFiles = [ \"subdir-needed-by-test\" ]; Or alternatively, override the source with a suitable filter function. components.tests.test.src = haskell-nix.haskellLib.cleanSourceWith { inherit src; subdir = \"path-to-package\"; filter = ... }; Multiple Git Repositories with cleanGits \u00b6 Some times it is handy to temporarily use a relative path between git repos. If the repos are individually cleaned this is not possible (since the cleaned version of one repo will never include the files of the other). There are 3 options: We could symlinkJoin the cleaned directories together, but the result could not be cleaned and any change would to either repo would result in a rebuild of everything. We could add one repo to the other as a submodule, but adding and then removing a submodule is a pain and it does not work well if you have more than one repo that needs to share the submodule. We could add a source-repository-package but then we would have to commit each change before testing. cleanGits allows us to specify a root directory and any number of sub directories containing git repos. For example if repoA and repoB are two git repos with cabal packages and want to use the repoB package when building repoA . First we can add ../repoB to repoA/cabal.project : packages: ./. ../repoB Then in repoA/default.nix we can use: haskell-nix.project { src = haskell-nix.haskellLib.cleanSourceWith { src = haskell-nix.haskellLib.cleanGits { name = \"root\"; src = ../.; # Parent dir that contains repoA and repoB gitDirs = [ \"repoA\" \"repoB\" ]; }; subDir = \"repoA\"; # Where to look for the `cabal.project` includeSiblings = true; # Tells it not to exclude `repoB` dir }; }","title":"Sourcing files only part of git repository using cleanGit"},{"location":"tutorials/clean-git/#cleangit","text":"To filter out just the files in your git index use haskell-nix.haskellLib.cleanGit { src = ./.; } where ./. is the root of your git repo (or a git work tree). First it filters just the files needed to run git index , then it uses the results of that to filter your directory. It does not need to parse the .gitignore files at all, but we do need to git add our files before they will be included. cleanGit source . In addition haskell.nix (including cleanGit ) uses a version of cleanSourceWith with a subdir argument to filter out just the package it is building. Then it uses the info from the cabal file to filter just the source dirs for the component it is building. That way if we modify a test in a package nix will not rebuild the library in that package (or anything that depends on that package's library). There is a downside to this though. If we have a test that depends on something outside the scope of what is described in its entry in the in the .cabal file it will not see it. For instance perhaps it needs to run hlint or doctest on the library source. There are ways to fix this with a module: Use extraSrcFiles to add dirs the test needs (this will not result in a change to the .cabal file the test will still be built the same). components.tests.test.extraSrcFiles = [ \"subdir-needed-by-test\" ]; Or alternatively, override the source with a suitable filter function. components.tests.test.src = haskell-nix.haskellLib.cleanSourceWith { inherit src; subdir = \"path-to-package\"; filter = ... };","title":"cleanGit"},{"location":"tutorials/clean-git/#multiple-git-repositories-with-cleangits","text":"Some times it is handy to temporarily use a relative path between git repos. If the repos are individually cleaned this is not possible (since the cleaned version of one repo will never include the files of the other). There are 3 options: We could symlinkJoin the cleaned directories together, but the result could not be cleaned and any change would to either repo would result in a rebuild of everything. We could add one repo to the other as a submodule, but adding and then removing a submodule is a pain and it does not work well if you have more than one repo that needs to share the submodule. We could add a source-repository-package but then we would have to commit each change before testing. cleanGits allows us to specify a root directory and any number of sub directories containing git repos. For example if repoA and repoB are two git repos with cabal packages and want to use the repoB package when building repoA . First we can add ../repoB to repoA/cabal.project : packages: ./. ../repoB Then in repoA/default.nix we can use: haskell-nix.project { src = haskell-nix.haskellLib.cleanSourceWith { src = haskell-nix.haskellLib.cleanGits { name = \"root\"; src = ../.; # Parent dir that contains repoA and repoB gitDirs = [ \"repoA\" \"repoB\" ]; }; subDir = \"repoA\"; # Where to look for the `cabal.project` includeSiblings = true; # Tells it not to exclude `repoB` dir }; }","title":"Multiple Git Repositories with cleanGits"},{"location":"tutorials/coverage/","text":"Coverage \u00b6 haskell.nix can generate coverage information for your package or project using Cabal's inbuilt hpc support. Prerequisites \u00b6 To get a sensible coverage report, you need to enable coverage on each of the packages of your project: pkgs.haskell-nix.project { src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; compiler-nix-name = \"ghc884\"; modules = [{ packages.$pkg.components.library.doCoverage = true; }]; } If you would like to make coverage optional, add an argument to your nix expression: { withCoverage ? false }: pkgs.haskell-nix.project { src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; compiler-nix-name = \"ghc884\"; modules = pkgs.lib.optional withCoverage [{ packages.$pkg.components.library.doCoverage = true; }]; } Per-package \u00b6 nix-build default.nix -A \"projectWithCoverage.$pkg.coverageReport\" This will generate a coverage report for the package you requested. All tests that are enabled (configured with doCheck == true ) are included in the coverage report. See the developer coverage docs for more information. Project-wide \u00b6 nix-build default.nix -A \"projectWithCoverage.projectCoverageReport\" This will generate a coverage report for all the local packages in your project. See the developer coverage docs for more information. Custom \u00b6 By default, the behaviour of the coverageReport attribute is to generate a coverage report that describes how that package affects the coverage of all local packages (including itself) in the project. The default behaviour of projectCoverageReport is to sum the default coverage reports (produced by the above process) of all local packages in the project. You can modify this behaviour by using the coverageReport and projectCoverageReport functions found in the haskell.nix library: let inherit (pkgs.haskell-nix) haskellLib; project = haskellLib.project { src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; compiler-nix-name = \"ghc884\"; modules = [{ packages.$pkgA.components.library.doCoverage = true; packages.$pkgB.components.library.doCoverage = true; }]; }; # Generate a coverage report for $pkgA that only includes the # unit-test check and only shows coverage information for $pkgA, not # $pkgB. custom$pkgACoverageReport = haskellLib.coverageReport rec { name = \"$pkgA-unit-tests-only\" inherit (project.$pkgA.components) library; checks = [project.$pkgA.components.checks.unit-test]; # Note that this is the default value of the \"mixLibraries\" # argument and so this line isn't really necessary. mixLibraries = [project.$pkgA.components.library]; }; custom$pkgBCoverageReport = haskellLib.coverageReport rec { name = \"$pkgB-unit-tests-only\" inherit (project.$pkgB.components) library; checks = [project.$pkgB.components.checks.unit-test]; mixLibraries = [project.$pkgB.components.library]; }; # Generate a project coverage report that only includes the unit # tests of the project, and only shows how each unit test effects # the coverage of it's package, and not other packages in the # project. allUnitTestsProjectReport = haskellLib.projectCoverageReport [custom$pkgACoverageReport custom$pkgBCoverageReport]; in { inherit project custom$pkgACoverageReport custom$pkgBCoverageReport allUnitTestsProjectCoverageReport; }","title":"Generating coverage information"},{"location":"tutorials/coverage/#coverage","text":"haskell.nix can generate coverage information for your package or project using Cabal's inbuilt hpc support.","title":"Coverage"},{"location":"tutorials/coverage/#prerequisites","text":"To get a sensible coverage report, you need to enable coverage on each of the packages of your project: pkgs.haskell-nix.project { src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; compiler-nix-name = \"ghc884\"; modules = [{ packages.$pkg.components.library.doCoverage = true; }]; } If you would like to make coverage optional, add an argument to your nix expression: { withCoverage ? false }: pkgs.haskell-nix.project { src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; compiler-nix-name = \"ghc884\"; modules = pkgs.lib.optional withCoverage [{ packages.$pkg.components.library.doCoverage = true; }]; }","title":"Prerequisites"},{"location":"tutorials/coverage/#per-package","text":"nix-build default.nix -A \"projectWithCoverage.$pkg.coverageReport\" This will generate a coverage report for the package you requested. All tests that are enabled (configured with doCheck == true ) are included in the coverage report. See the developer coverage docs for more information.","title":"Per-package"},{"location":"tutorials/coverage/#project-wide","text":"nix-build default.nix -A \"projectWithCoverage.projectCoverageReport\" This will generate a coverage report for all the local packages in your project. See the developer coverage docs for more information.","title":"Project-wide"},{"location":"tutorials/coverage/#custom","text":"By default, the behaviour of the coverageReport attribute is to generate a coverage report that describes how that package affects the coverage of all local packages (including itself) in the project. The default behaviour of projectCoverageReport is to sum the default coverage reports (produced by the above process) of all local packages in the project. You can modify this behaviour by using the coverageReport and projectCoverageReport functions found in the haskell.nix library: let inherit (pkgs.haskell-nix) haskellLib; project = haskellLib.project { src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; compiler-nix-name = \"ghc884\"; modules = [{ packages.$pkgA.components.library.doCoverage = true; packages.$pkgB.components.library.doCoverage = true; }]; }; # Generate a coverage report for $pkgA that only includes the # unit-test check and only shows coverage information for $pkgA, not # $pkgB. custom$pkgACoverageReport = haskellLib.coverageReport rec { name = \"$pkgA-unit-tests-only\" inherit (project.$pkgA.components) library; checks = [project.$pkgA.components.checks.unit-test]; # Note that this is the default value of the \"mixLibraries\" # argument and so this line isn't really necessary. mixLibraries = [project.$pkgA.components.library]; }; custom$pkgBCoverageReport = haskellLib.coverageReport rec { name = \"$pkgB-unit-tests-only\" inherit (project.$pkgB.components) library; checks = [project.$pkgB.components.checks.unit-test]; mixLibraries = [project.$pkgB.components.library]; }; # Generate a project coverage report that only includes the unit # tests of the project, and only shows how each unit test effects # the coverage of it's package, and not other packages in the # project. allUnitTestsProjectReport = haskellLib.projectCoverageReport [custom$pkgACoverageReport custom$pkgBCoverageReport]; in { inherit project custom$pkgACoverageReport custom$pkgBCoverageReport allUnitTestsProjectCoverageReport; }","title":"Custom"},{"location":"tutorials/cross-compilation/","text":"Cross compilation of Haskell projects involves building a version of GHC that outputs code for the target platform, and providing builds of all library dependencies for that platform. First, understand how to cross-compile a normal package from Nixpkgs. Matthew Bauer's Beginners' guide to cross compilation in Nixpkgs is a useful resource. Using an example from the guide, this builds GNU Hello for a Raspberry Pi: nix build -f '<nixpkgs>' pkgsCross.raspberryPi.hello We will use the same principle in Haskell.nix \u2014 replacing the normal package set pkgs with a cross-compiling package set pkgsCross.raspberryPi . Raspberry Pi example \u00b6 This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! Hint The above example won't build, but you can try and see, if you like. It will fail on clock-0.7.2 , which needs a patch to build. To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags, adding patches, and so on. Note Note that haskell.nix will automatically use qemu to emulate the target when necessary to run Template Haskell splices. Static executables with Musl libc \u00b6 Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ \"--disable-executable-dynamic\" \"--disable-shared\" \"--ghc-option=-optl=-pthread\" \"--ghc-option=-optl=-static\" \"--ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib\" \"--ghc-option=-optl=-L${zlib.static}/lib\" ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this. How to cross-compile your project \u00b6 Set up your project Haskell package set. # default.nix { pkgs ? import <nixpkgs> {} let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = [ { # You will need to put build fixes here. } ]; }; in pkgSet.config.hsPkgs Apply that package set to the Nixpkgs cross package sets that you are interested in. We are going to expand the pkgs.pkgsCross shortcut to be more explicit. let pkgs = import <nixpkgs> {} in { shortcut = pkgs.pkgsCross.SYSTEM; actual = import <nixpkgs> { crossSystem = pkgs.lib.systems.examples.SYSTEM; }; } In the above example, for any SYSTEM , shortcut and actual are the same package set. # release.nix let myProject = import ./default.nix; pkgsNative = import <nixpkgs> {}; pkgsRaspberryPi = import <nixpkgs> { crossSystem = pkgsNative.lib.systems.examples.raspberryPi; }; native = myProject { pkgs = pkgsNative; }; crossRaspberryPi = myProject { pkgs = pkgsRaspberryPi; }; in { my-project-native = native.my-project.components.exes.my-project; my-project-raspberry-pi = crossRaspberryPi.my-project.components.exes.my-project; } Try to build it, and apply fixes to the modules list, until there are no errors left.","title":"Cross-compiling your project"},{"location":"tutorials/cross-compilation/#raspberry-pi-example","text":"This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! Hint The above example won't build, but you can try and see, if you like. It will fail on clock-0.7.2 , which needs a patch to build. To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags, adding patches, and so on. Note Note that haskell.nix will automatically use qemu to emulate the target when necessary to run Template Haskell splices.","title":"Raspberry Pi example"},{"location":"tutorials/cross-compilation/#static-executables-with-musl-libc","text":"Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import <nixpkgs> {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ \"--disable-executable-dynamic\" \"--disable-shared\" \"--ghc-option=-optl=-pthread\" \"--ghc-option=-optl=-static\" \"--ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib\" \"--ghc-option=-optl=-L${zlib.static}/lib\" ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this.","title":"Static executables with Musl libc"},{"location":"tutorials/cross-compilation/#how-to-cross-compile-your-project","text":"Set up your project Haskell package set. # default.nix { pkgs ? import <nixpkgs> {} let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = [ { # You will need to put build fixes here. } ]; }; in pkgSet.config.hsPkgs Apply that package set to the Nixpkgs cross package sets that you are interested in. We are going to expand the pkgs.pkgsCross shortcut to be more explicit. let pkgs = import <nixpkgs> {} in { shortcut = pkgs.pkgsCross.SYSTEM; actual = import <nixpkgs> { crossSystem = pkgs.lib.systems.examples.SYSTEM; }; } In the above example, for any SYSTEM , shortcut and actual are the same package set. # release.nix let myProject = import ./default.nix; pkgsNative = import <nixpkgs> {}; pkgsRaspberryPi = import <nixpkgs> { crossSystem = pkgsNative.lib.systems.examples.raspberryPi; }; native = myProject { pkgs = pkgsNative; }; crossRaspberryPi = myProject { pkgs = pkgsRaspberryPi; }; in { my-project-native = native.my-project.components.exes.my-project; my-project-raspberry-pi = crossRaspberryPi.my-project.components.exes.my-project; } Try to build it, and apply fixes to the modules list, until there are no errors left.","title":"How to cross-compile your project"},{"location":"tutorials/development/","text":"Haskell.nix also provides reproducible development environments for your Haskell projects. These environments can contain not only GHC and your Haskell package dependencies, but also the required system libraries and build tools. Inside the development shell, you can run commands such as ghc , ghci , or cabal new\u2011build ( cabal build on Cabal 3.0), and they will have all dependencies available. Every dependency will be cached in your Nix store. If you have set up Hydra CI, then your team can share pre-built dependencies. These examples assume that you have created your package set as described in Creating Nix builds for your projects and it exists in a file called default.nix . Note Old-style cabal build and stack builds are not (yet) supported. For example, stack will (by design) download and rebuild all dependencies, even though they are available in the shell. However, if you have a Stack project, you can generate the package set with Haskell.nix, then use cabal new\u2011build to work on it. Starting Cabal 3.0 cabal build will work out of the box, as new style builds are the default. How to get a development shell \u00b6 If you have a Cabal or Stack project with one or more packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import <nixpkgs> {} }: let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a \"hoogle\" command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). # Some common tools can be added with the `tools` argument tools = { cabal = \"3.2.0.0\"; hlint = \"2.2.11\"; }; # See overlays/tools.nix for more details # Some you may need to get some other way. buildInputs = with pkgs.haskellPackages; [ ghcid ]; # Prevents cabal from choosing alternate plans, so that # *all* dependencies are provided by Nix. exactDeps = true; } See also: Haskell.nix Library Reference: shellFor How to get a local Hoogle index \u00b6 If you need a local Hoogle for all the dependencies of your project create this file # shell-hoogle.nix let hsPkgs = import ./default.nix {}; in hsPkgs.shellFor { packages = ps: [ps.my-package]; withHoogle = true; } and run nix-shell shell-hoogle.nix --run \"hoogle server --local\" . This will open a local Hoogle server at http://127.0.0.1:8080 . How to get an ad-hoc development shell including certain packages \u00b6 This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages . How to get packages from a certain Stackage snapshot \u00b6 Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.snapshots.\"lts-13.18\".alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built. Emacs IDE support \u00b6 Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continuously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl . Using nix repl \u00b6 It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { nixpkgs ? <nixpkgs> }: rec { haskell = import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; pkgNames = haskell.pkgs.lib.attrNames haskell.haskell-nix.snapshots.\"lts-13.18\"; } Load the example file: $ nix repl '<nixpkgs>' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading '<nixpkgs>'... Added 10403 variables. Loading 'example.nix'... Added 2 variables. nix-repl> lib.take 5 pkgNames [ \"ALUT\" \"ANum\" \"Allure\" \"Boolean\" \"BoundedChan\" ] nix-repl> Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"Creating a development environment"},{"location":"tutorials/development/#how-to-get-a-development-shell","text":"If you have a Cabal or Stack project with one or more packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import <nixpkgs> {} }: let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a \"hoogle\" command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). # Some common tools can be added with the `tools` argument tools = { cabal = \"3.2.0.0\"; hlint = \"2.2.11\"; }; # See overlays/tools.nix for more details # Some you may need to get some other way. buildInputs = with pkgs.haskellPackages; [ ghcid ]; # Prevents cabal from choosing alternate plans, so that # *all* dependencies are provided by Nix. exactDeps = true; } See also: Haskell.nix Library Reference: shellFor","title":"How to get a development shell"},{"location":"tutorials/development/#how-to-get-a-local-hoogle-index","text":"If you need a local Hoogle for all the dependencies of your project create this file # shell-hoogle.nix let hsPkgs = import ./default.nix {}; in hsPkgs.shellFor { packages = ps: [ps.my-package]; withHoogle = true; } and run nix-shell shell-hoogle.nix --run \"hoogle server --local\" . This will open a local Hoogle server at http://127.0.0.1:8080 .","title":"How to get a local Hoogle index"},{"location":"tutorials/development/#how-to-get-an-ad-hoc-development-shell-including-certain-packages","text":"This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages .","title":"How to get an ad-hoc development shell including certain packages"},{"location":"tutorials/development/#how-to-get-packages-from-a-certain-stackage-snapshot","text":"Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; nixpkgs = import haskellNix.sources.nixpkgs-1909 haskellNix.nixpkgsArgs; haskell = nixpkgs.haskell-nix; in haskell.snapshots.\"lts-13.18\".alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built.","title":"How to get packages from a certain Stackage snapshot"},{"location":"tutorials/development/#emacs-ide-support","text":"Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continuously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl .","title":"Emacs IDE support"},{"location":"tutorials/development/#using-nix-repl","text":"It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { nixpkgs ? <nixpkgs> }: rec { haskell = import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs; pkgNames = haskell.pkgs.lib.attrNames haskell.haskell-nix.snapshots.\"lts-13.18\"; } Load the example file: $ nix repl '<nixpkgs>' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading '<nixpkgs>'... Added 10403 variables. Loading 'example.nix'... Added 2 variables. nix-repl> lib.take 5 pkgNames [ \"ALUT\" \"ANum\" \"Allure\" \"Boolean\" \"BoundedChan\" ] nix-repl> Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"Using nix repl"},{"location":"tutorials/getting-started/","text":"Getting started \u00b6 haskell.nix can automatically translate your Cabal or Stack project and its dependencies into Nix code. Assuming you have Nix installed, you can start setting up your project. Setting up the Cachix binary cache \u00b6 You can avoid compiling GHC and nix-tools by configuring Cachix so you can benefit from the binary cache built by CI: $ nix-env -iA cachix -f https://cachix.org/api/v1/install installing 'cachix-0.3.8' building '/nix/store/bh176xhpk4wrjm56iahm86wf85jaz23v-user-environment.drv'... created 42 symlinks in user environment $ cachix use iohk Configured https://iohk.cachix.org binary cache in ~/.config/nix/nix.conf Note: haskell.nix currently uses multiple CI providers to build derivations and store outputs. To improve your chances of getting a cache hit, you might want to add the following additional substituter to ~/.config/nix/nix.conf : trusted-public-keys = [...] hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= [...] substituters = [...] https://hydra.iohk.io [...] Scaffolding \u00b6 The following work with stack.yaml and cabal.project based projects. Add default.nix : { # Fetch the latest haskell.nix and import its default.nix haskellNix ? import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {} # haskell.nix provides access to the nixpkgs pins which are used by our CI, # hence you will be more likely to get cache hits when using these. # But you can also just use your own, e.g. '<nixpkgs>'. , nixpkgsSrc ? haskellNix.sources.nixpkgs-2003 # haskell.nix provides some arguments to be passed to nixpkgs, including some # patches and also the haskell.nix functionality itself as an overlay. , nixpkgsArgs ? haskellNix.nixpkgsArgs # import nixpkgs with overlays , pkgs ? import nixpkgsSrc nixpkgsArgs }: pkgs.haskell-nix.project { # 'cleanGit' cleans a source directory based on the files known by git src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; # For `cabal.project` based projects specify the GHC version to use. compiler-nix-name = \"ghc884\"; # Not used for `stack.yaml` based projects. } git dependencies If you have git dependencies in your project, you'll need to calculate sha256 hashes for them . Working with a project \u00b6 Top-level attributes are Haskell packages (incl. dependencies) part of your project. To build the library component of a package in the project run: nix-build -A your-package-name.components.library There are also other components such as exes , tests , benchmarks and all . To build an executable: nix-build -A your-package-name.components.exes.your-exe-name To open a shell for use with cabal run: nix-shell -A shellFor cabal new-repl your-package-name:library:your-package-name cabal new-build your-package-name To open a shell for use with stack see the following issue . Pinning the haskell.nix version \u00b6 For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin haskell.nix (as you would pin Nixpkgs). This will make your builds reproducible, more predictable, and faster (because the fixed version is cached). Straightforward way of doing this is to change the branch name to a revision. { # Fetch a specific haskell.nix and import its default.nix haskellNix ? import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/f1a94a4c82a2ab999a67c3b84269da78d89f0075.tar.gz\") {} ... There are other possible schemes for pinning. See Bumping Hackage and Stackage snapshots and Nix tutorial on reproducibility using pinning . Going forward \u00b6 Read through project function reference to see how the API works. There are a number of things to explore further in the tutorials section.","title":"Getting Started"},{"location":"tutorials/getting-started/#getting-started","text":"haskell.nix can automatically translate your Cabal or Stack project and its dependencies into Nix code. Assuming you have Nix installed, you can start setting up your project.","title":"Getting started"},{"location":"tutorials/getting-started/#setting-up-the-cachix-binary-cache","text":"You can avoid compiling GHC and nix-tools by configuring Cachix so you can benefit from the binary cache built by CI: $ nix-env -iA cachix -f https://cachix.org/api/v1/install installing 'cachix-0.3.8' building '/nix/store/bh176xhpk4wrjm56iahm86wf85jaz23v-user-environment.drv'... created 42 symlinks in user environment $ cachix use iohk Configured https://iohk.cachix.org binary cache in ~/.config/nix/nix.conf Note: haskell.nix currently uses multiple CI providers to build derivations and store outputs. To improve your chances of getting a cache hit, you might want to add the following additional substituter to ~/.config/nix/nix.conf : trusted-public-keys = [...] hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= [...] substituters = [...] https://hydra.iohk.io [...]","title":"Setting up the Cachix binary cache"},{"location":"tutorials/getting-started/#scaffolding","text":"The following work with stack.yaml and cabal.project based projects. Add default.nix : { # Fetch the latest haskell.nix and import its default.nix haskellNix ? import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz\") {} # haskell.nix provides access to the nixpkgs pins which are used by our CI, # hence you will be more likely to get cache hits when using these. # But you can also just use your own, e.g. '<nixpkgs>'. , nixpkgsSrc ? haskellNix.sources.nixpkgs-2003 # haskell.nix provides some arguments to be passed to nixpkgs, including some # patches and also the haskell.nix functionality itself as an overlay. , nixpkgsArgs ? haskellNix.nixpkgsArgs # import nixpkgs with overlays , pkgs ? import nixpkgsSrc nixpkgsArgs }: pkgs.haskell-nix.project { # 'cleanGit' cleans a source directory based on the files known by git src = pkgs.haskell-nix.haskellLib.cleanGit { name = \"haskell-nix-project\"; src = ./.; }; # For `cabal.project` based projects specify the GHC version to use. compiler-nix-name = \"ghc884\"; # Not used for `stack.yaml` based projects. } git dependencies If you have git dependencies in your project, you'll need to calculate sha256 hashes for them .","title":"Scaffolding"},{"location":"tutorials/getting-started/#working-with-a-project","text":"Top-level attributes are Haskell packages (incl. dependencies) part of your project. To build the library component of a package in the project run: nix-build -A your-package-name.components.library There are also other components such as exes , tests , benchmarks and all . To build an executable: nix-build -A your-package-name.components.exes.your-exe-name To open a shell for use with cabal run: nix-shell -A shellFor cabal new-repl your-package-name:library:your-package-name cabal new-build your-package-name To open a shell for use with stack see the following issue .","title":"Working with a project"},{"location":"tutorials/getting-started/#pinning-the-haskellnix-version","text":"For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin haskell.nix (as you would pin Nixpkgs). This will make your builds reproducible, more predictable, and faster (because the fixed version is cached). Straightforward way of doing this is to change the branch name to a revision. { # Fetch a specific haskell.nix and import its default.nix haskellNix ? import (builtins.fetchTarball \"https://github.com/input-output-hk/haskell.nix/archive/f1a94a4c82a2ab999a67c3b84269da78d89f0075.tar.gz\") {} ... There are other possible schemes for pinning. See Bumping Hackage and Stackage snapshots and Nix tutorial on reproducibility using pinning .","title":"Pinning the haskell.nix version"},{"location":"tutorials/getting-started/#going-forward","text":"Read through project function reference to see how the API works. There are a number of things to explore further in the tutorials section.","title":"Going forward"},{"location":"tutorials/hackage-stackage/","text":"Bumping Hackage and Stackage snapshots \u00b6 haskell.nix relies on some generated data providing information about packages in Hackage and Stackage snapshots. These are kept in hackage.nix and stackage.nix respectively. If your project depends on a Hackage package, then the hackage.nix revision used must be new enough to contain that, and likewise for Stackage snaphots and stackage.nix . Updating and pinning hackage.nix and stackage.nix \u00b6 haskell.nix pins particular revisions of these repositories internally, both for our own usage in testing, and so that users have a sensible default when getting started. These revisions are updated nightly, so you can get newer revisions of hackage.nix and stackage.nix by updating your revision of haskell.nix itself. However, this exposes you to changes in haskell.nix which you may not want, such as changes that force compiler rebuilds, or the occasional bug. Instead, you can pin hackage.nix and stackage.nix independently. For example: let # You can use a tool like `niv` to manage this boilerplate hackageSrc = builtins.fetchTarball https://github.com/input-output-hk/hackage.nix/archive/master.tar.gz; stackageSrc = builtins.fetchTarball https://github.com/input-output-hk/stackage.nix/archive/master.tar.gz; haskellSrc = builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz; haskellNix = import haskellSrc { # This allows you to override the pins used by `haskell.nix` internally sourcesOverride = { hackage = hackageSrc; stackage = stackageSrc; }; }; in ... This way you can change the revisions of hackage.nix and stackage.nix without changing haskell.nix . However, bear in mind that Stackage refers to Hackage, so your Stackage pin should never be newer than your Hackage pin.","title":"Bumping Hackage and Stackage snapshots"},{"location":"tutorials/hackage-stackage/#bumping-hackage-and-stackage-snapshots","text":"haskell.nix relies on some generated data providing information about packages in Hackage and Stackage snapshots. These are kept in hackage.nix and stackage.nix respectively. If your project depends on a Hackage package, then the hackage.nix revision used must be new enough to contain that, and likewise for Stackage snaphots and stackage.nix .","title":"Bumping Hackage and Stackage snapshots"},{"location":"tutorials/hackage-stackage/#updating-and-pinning-hackagenix-and-stackagenix","text":"haskell.nix pins particular revisions of these repositories internally, both for our own usage in testing, and so that users have a sensible default when getting started. These revisions are updated nightly, so you can get newer revisions of hackage.nix and stackage.nix by updating your revision of haskell.nix itself. However, this exposes you to changes in haskell.nix which you may not want, such as changes that force compiler rebuilds, or the occasional bug. Instead, you can pin hackage.nix and stackage.nix independently. For example: let # You can use a tool like `niv` to manage this boilerplate hackageSrc = builtins.fetchTarball https://github.com/input-output-hk/hackage.nix/archive/master.tar.gz; stackageSrc = builtins.fetchTarball https://github.com/input-output-hk/stackage.nix/archive/master.tar.gz; haskellSrc = builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz; haskellNix = import haskellSrc { # This allows you to override the pins used by `haskell.nix` internally sourcesOverride = { hackage = hackageSrc; stackage = stackageSrc; }; }; in ... This way you can change the revisions of hackage.nix and stackage.nix without changing haskell.nix . However, bear in mind that Stackage refers to Hackage, so your Stackage pin should never be newer than your Hackage pin.","title":"Updating and pinning hackage.nix and stackage.nix"},{"location":"tutorials/materialization/","text":"Materialization \u00b6 What is materialization? \u00b6 Capturing and storing the nix files for a project so that they do not need to be built (or checked). This allows us to cache the input of an IFD (import from derivation). Why use materialization? \u00b6 Using functions like project , cabalProject , stackProject and hackage-package results in a lot of dependencies (all the dependencies of nix-tools for instance). They can be slow to calculate (even if no work needs to be done it is not unusual for it to take 5 seconds per project). They can be slow to build (or download) on machines that do not yet have them in the nix store. Hydra does not show progress because it does not provide feedback until it has a list of jobs and the list of jobs cannot depends on the nix being present (although this is often blamed on IFD it would be the same if it wrote out JSON files and read them in) When is it ok to materialize? \u00b6 The nix is unlikely to change frequently (and when it does you are happy to manually update it). You are happy to script something to update the materialized nix files automatically. You are certain that the IFD you materialize is not system -dependent. If it was you'd obtain different nix expressions depending on which system the IFD was evaluated. How can we materialize the nix files? \u00b6 Lets say we want to build hlint . We might start with an hlint file that looks like this: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; }; in hlint.components.exes.hlint Building this may result in a lot of output, but if you build it again it should give just: $ nix-build hlint.nix trace: Using latest index state for hlint! trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To materialize the nix files we need to take care to pin down the inputs. For cabal projects this means we must specify the index-state of hackage we want to use: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint.components.exes.hlint Now if we build again we get a hint telling use how to calculate a suitable sha256 hash to turn the derivation containing the nix files into a fixed output derivation: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/` /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint $ nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/ 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4 We can add the hash as plan-sha256 or ( stack-sha256 for stack projects) let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; }; in hlint.components.exes.hlint Just adding the hash might help reuse of the cached nix, but nix will still calculate all the dependencies (which can add seconds to nix-build and nix-shell commands when no other work is needed) and users who do not yet have the dependencies in their store will have to wait while they are built or downloaded. Running nix build again gives us a hint on what we can do next: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: To materialize, point `materialized` to a copy of /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To capture the nix we can do something like: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; }; in hlint.components.exes.hlint Now we can copy the nix files needed and build with: $ cp -r /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs hlint.materialized $ nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint We may want to run chmod -R +w hlint.materialized as the files copied from the store will be read only. How can we check sha256 and materialized are up to date? \u00b6 Let's pretend we had to go back to hlint version 2.2.10 . We can tell haskell.nix to check the materialization either by: Removing the materialization files with rm -rf hlint.materialized Temporarily adding checkMaterialization = true; If we choose to add the checkMaterialization flag you would have: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; checkMaterialization = true; }; in hlint.components.exes.hlint This will fail and report the details of what is wrong and how to fix it: $ nix-build hlint.nix ... Calculated hash for hlint-plan-to-nix-pkgs was not 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4. New hash is : plan-sha256 = \"0zsi3wv92qax33ic4n5dfsqd1r9qam1k75za3c5jqgdxl3hy8vph\"; Materialized nix used for hlint-plan-to-nix-pkgs incorrect. To fix run : rm -rf /Users/hamish/iohk/haskell.nix/hlint.materialized cp -r /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs /Users/hamish/iohk/haskell.nix/hlint.materialized chmod -R +w /Users/hamish/iohk/haskell.nix/hlint.materialized builder for '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed with exit code 1 error: build of '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed (use '--show-trace' to show detailed location information) Checking the materialization requires nix to do all the work that materialization avoids. So while it might be tempting to leave checkMaterialization = true all the time, we would be better off just removing materialized and plan-sha256 . How can we update the nix files with a script? \u00b6 There are versions of the functions ( project' , cabalProject' , stackProject' and hackage-project ) that also return the nix as plan-nix or stack-nix . By calling one of these functions without the hash and materialized nix we can find out what nix files should be. For instance: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-project { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint $ nix-build hlint.nix -A plan-nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs/` /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs We can have the script copy $(nix-build hlint.nix -A plan-nix --no-out-link) and use nix-hash to calculate the new value for plan-sha256 . Can we skip making a copy and use materialized = /nix/store/... ? \u00b6 Yes and it gives us the same speed improvement, however: It does not help at all in restricted-eval mode (Hydra). Users will still wind up building or downloading the dependencies needed to build the nix files (if they do not have them). For those reasons it might be best to make a copy instead of using the /nix/store/... path directly. If you really want to use the /nix/store/... path directly you should guard against the path not existing as passing in a non-existing path is now an error: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlintPlan = /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = if __pathExists hlintPlan then hlintPlan else null; }; in hlint.components.exes.hlint Running when no building is needed is still slow in restricted evaluation mode. $ time nix-build --option restrict-eval true -I . --option allowed-uris \"https://github.com/NixOS https://github.com/input-output-hk\" hlint.nix --show-trace trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m4.463s user 0m4.440s sys 0m0.461s $ time nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m2.206s user 0m1.665s sys 0m0.332s","title":"Materialization: Speeding up Nix evaluation"},{"location":"tutorials/materialization/#materialization","text":"","title":"Materialization"},{"location":"tutorials/materialization/#what-is-materialization","text":"Capturing and storing the nix files for a project so that they do not need to be built (or checked). This allows us to cache the input of an IFD (import from derivation).","title":"What is materialization?"},{"location":"tutorials/materialization/#why-use-materialization","text":"Using functions like project , cabalProject , stackProject and hackage-package results in a lot of dependencies (all the dependencies of nix-tools for instance). They can be slow to calculate (even if no work needs to be done it is not unusual for it to take 5 seconds per project). They can be slow to build (or download) on machines that do not yet have them in the nix store. Hydra does not show progress because it does not provide feedback until it has a list of jobs and the list of jobs cannot depends on the nix being present (although this is often blamed on IFD it would be the same if it wrote out JSON files and read them in)","title":"Why use materialization?"},{"location":"tutorials/materialization/#when-is-it-ok-to-materialize","text":"The nix is unlikely to change frequently (and when it does you are happy to manually update it). You are happy to script something to update the materialized nix files automatically. You are certain that the IFD you materialize is not system -dependent. If it was you'd obtain different nix expressions depending on which system the IFD was evaluated.","title":"When is it ok to materialize?"},{"location":"tutorials/materialization/#how-can-we-materialize-the-nix-files","text":"Lets say we want to build hlint . We might start with an hlint file that looks like this: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; }; in hlint.components.exes.hlint Building this may result in a lot of output, but if you build it again it should give just: $ nix-build hlint.nix trace: Using latest index state for hlint! trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To materialize the nix files we need to take care to pin down the inputs. For cabal projects this means we must specify the index-state of hackage we want to use: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint.components.exes.hlint Now if we build again we get a hint telling use how to calculate a suitable sha256 hash to turn the derivation containing the nix files into a fixed output derivation: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/` /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint $ nix-hash --base32 --type sha256 /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs/ 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4 We can add the hash as plan-sha256 or ( stack-sha256 for stack projects) let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; }; in hlint.components.exes.hlint Just adding the hash might help reuse of the cached nix, but nix will still calculate all the dependencies (which can add seconds to nix-build and nix-shell commands when no other work is needed) and users who do not yet have the dependencies in their store will have to wait while they are built or downloaded. Running nix build again gives us a hint on what we can do next: $ nix-build hlint.nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: To materialize, point `materialized` to a copy of /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint To capture the nix we can do something like: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; }; in hlint.components.exes.hlint Now we can copy the nix files needed and build with: $ cp -r /nix/store/8z6p4237rin3c6c1lmjwshmj8rdqrhw2-hlint-plan-to-nix-pkgs hlint.materialized $ nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint We may want to run chmod -R +w hlint.materialized as the files copied from the store will be read only.","title":"How can we materialize the nix files?"},{"location":"tutorials/materialization/#how-can-we-check-sha256-and-materialized-are-up-to-date","text":"Let's pretend we had to go back to hlint version 2.2.10 . We can tell haskell.nix to check the materialization either by: Removing the materialization files with rm -rf hlint.materialized Temporarily adding checkMaterialization = true; If we choose to add the checkMaterialization flag you would have: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = ./hlint.materialized; checkMaterialization = true; }; in hlint.components.exes.hlint This will fail and report the details of what is wrong and how to fix it: $ nix-build hlint.nix ... Calculated hash for hlint-plan-to-nix-pkgs was not 02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4. New hash is : plan-sha256 = \"0zsi3wv92qax33ic4n5dfsqd1r9qam1k75za3c5jqgdxl3hy8vph\"; Materialized nix used for hlint-plan-to-nix-pkgs incorrect. To fix run : rm -rf /Users/hamish/iohk/haskell.nix/hlint.materialized cp -r /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs /Users/hamish/iohk/haskell.nix/hlint.materialized chmod -R +w /Users/hamish/iohk/haskell.nix/hlint.materialized builder for '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed with exit code 1 error: build of '/nix/store/a5zmgfjfxahapw0q8hd2da5bg7knqvbx-hlint-plan-to-nix-pkgs.drv' failed (use '--show-trace' to show detailed location information) Checking the materialization requires nix to do all the work that materialization avoids. So while it might be tempting to leave checkMaterialization = true all the time, we would be better off just removing materialized and plan-sha256 .","title":"How can we check sha256 and materialized are up to date?"},{"location":"tutorials/materialization/#how-can-we-update-the-nix-files-with-a-script","text":"There are versions of the functions ( project' , cabalProject' , stackProject' and hackage-project ) that also return the nix as plan-nix or stack-nix . By calling one of these functions without the hash and materialized nix we can find out what nix files should be. For instance: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlint = pkgs.haskell-nix.hackage-project { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.10\"; index-state = \"2020-04-15T00:00:00Z\"; }; in hlint $ nix-build hlint.nix -A plan-nix trace: Using index-state: 2020-04-15T00:00:00Z for hlint trace: Get `plan-sha256` with `nix-hash --base32 --type sha256 /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs/` /nix/store/ywdhbx9rzzkfc60c5vzk7cins2hnvkgx-hlint-plan-to-nix-pkgs We can have the script copy $(nix-build hlint.nix -A plan-nix --no-out-link) and use nix-hash to calculate the new value for plan-sha256 .","title":"How can we update the nix files with a script?"},{"location":"tutorials/materialization/#can-we-skip-making-a-copy-and-use-materialized-nixstore","text":"Yes and it gives us the same speed improvement, however: It does not help at all in restricted-eval mode (Hydra). Users will still wind up building or downloading the dependencies needed to build the nix files (if they do not have them). For those reasons it might be best to make a copy instead of using the /nix/store/... path directly. If you really want to use the /nix/store/... path directly you should guard against the path not existing as passing in a non-existing path is now an error: let inherit (import ./. {}) sources nixpkgsArgs; pkgs = import sources.nixpkgs nixpkgsArgs; hlintPlan = /nix/store/kk047cqsjvbj4w8psv4l05abdcnyrqdc-hlint-plan-to-nix-pkgs; hlint = pkgs.haskell-nix.hackage-package { compiler-nix-name = \"ghc884\"; name = \"hlint\"; version = \"2.2.11\"; index-state = \"2020-04-15T00:00:00Z\"; plan-sha256 = \"02hasr27a994sml1fzf8swb716lm6lgixxr53y0gxkhw437xkck4\"; materialized = if __pathExists hlintPlan then hlintPlan else null; }; in hlint.components.exes.hlint Running when no building is needed is still slow in restricted evaluation mode. $ time nix-build --option restrict-eval true -I . --option allowed-uris \"https://github.com/NixOS https://github.com/input-output-hk\" hlint.nix --show-trace trace: Using index-state: 2020-04-15T00:00:00Z for hlint /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m4.463s user 0m4.440s sys 0m0.461s $ time nix-build hlint.nix /nix/store/rnfz66v7k8i38c8rsmchzsyqjrmrbdpk-hlint-2.2.11-exe-hlint real 0m2.206s user 0m1.665s sys 0m0.332s","title":"Can we skip making a copy and use materialized = /nix/store/...?"},{"location":"tutorials/pkg-map/","text":"Mapping non-Haskell dependencies to Nixpkgs \u00b6 Cabal files may contain dependencies to external non-Haskell dependencies via: build-tool-depends pkgconfig-depends frameworks extra-libraries If there is a pkgs attribute in Nixpkgs that matches the name given in the Cabal file, then it will be added as a dependency (see the output of cabal-to-nix ). Otherwise, there needs to be a mapping from Cabal file names (decided by the package author) to Nix package identifiers. Nixpkgs overlay \u00b6 The user may solve it by themself by overriding Nixpkgs and adding a package alias. For example: nixpkgs.overlays = [ (self: super: { icuuc = self.icu; icui18n = self.icu; icudata = self.icu; }) ]; Mapping in Haskell.nix \u00b6 Alternatively, if the name is commonly used, an alias can be added to the Haskell.nix sources, so that it's solved for all users. lib/pkgconf-nixpkgs-map.nix - for pkgconfig-depends lib/system-nixpkgs-map.nix - for build-tool-depends , frameworks , extra-libraries , etc. Open a PR Please go ahead and open a pull request to improve the package mappings.","title":"Mapping non-Haskell dependencies to Nixpkgs"},{"location":"tutorials/pkg-map/#mapping-non-haskell-dependencies-to-nixpkgs","text":"Cabal files may contain dependencies to external non-Haskell dependencies via: build-tool-depends pkgconfig-depends frameworks extra-libraries If there is a pkgs attribute in Nixpkgs that matches the name given in the Cabal file, then it will be added as a dependency (see the output of cabal-to-nix ). Otherwise, there needs to be a mapping from Cabal file names (decided by the package author) to Nix package identifiers.","title":"Mapping non-Haskell dependencies to Nixpkgs"},{"location":"tutorials/pkg-map/#nixpkgs-overlay","text":"The user may solve it by themself by overriding Nixpkgs and adding a package alias. For example: nixpkgs.overlays = [ (self: super: { icuuc = self.icu; icui18n = self.icu; icudata = self.icu; }) ];","title":"Nixpkgs overlay"},{"location":"tutorials/pkg-map/#mapping-in-haskellnix","text":"Alternatively, if the name is commonly used, an alias can be added to the Haskell.nix sources, so that it's solved for all users. lib/pkgconf-nixpkgs-map.nix - for pkgconfig-depends lib/system-nixpkgs-map.nix - for build-tool-depends , frameworks , extra-libraries , etc. Open a PR Please go ahead and open a pull request to improve the package mappings.","title":"Mapping in Haskell.nix"},{"location":"tutorials/source-repository-hashes/","text":"Handling git repositories in projects \u00b6 Both stack.yaml and cabal.project files can contain references to git repositories containing the version of a particular package that we wish to use. This is mostly handled automatically by nix-tools and haskell.nix however when we want to use a nix system that is configured to use restricted mode (typically hydra) it will need additional hashes for the referenced repositories. When using project , cabalProject or stackProject functions you can include the hash needed in a comment. To calculate the hash use nix-prefetch-git : $ nix-prefetch-git https://github.com/input-output-hk/haskell.nix.git bc01ebc05a8105035c9449943046b46c8364b932 ... { \"url\": \"https://github.com/input-output-hk/haskell.nix.git\", \"rev\": \"bc01ebc05a8105035c9449943046b46c8364b932\", \"date\": \"2019-05-30T13:13:18+08:00\", \"sha256\": \"003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z\", \"fetchSubmodules\": false } Cabal.project \u00b6 Add a --sha256 comment to the cabal.project file: source-repository-package type: git location: https://github.com/input-output-hk/haskell.nix.git tag: bc01ebc05a8105035c9449943046b46c8364b932 subdir: test/cabal-simple --sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z Stack \u00b6 Add a # nix-sha256 comment to the stack.yaml file: extra-deps: - git: https://github.com/input-output-hk/haskell.nix.git commit: bc01ebc05a8105035c9449943046b46c8364b932 subdirs: - test/cabal-simple # nix-sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z Avoiding modifying cabal.project and stack.yaml \u00b6 In some cases we cannot modify the cabal.project or stack.yaml file to add sha256 comments. As an alternative we can pass in a sha256map . For instance, pandoc includes a cabal.project file on hackage which includes a source-repository-package stanza for pandoc-citeproc : { haskell-nix, testSrc } : let pandoc = haskell-nix.hackage-package { name = \"pandoc\"; version = \"2.9.2.1\"; index-state = \"2020-04-15T00:00:00Z\"; # Function that returns a sha256 string by looking up the location # and tag in a nested attrset sha256map = { \"https://github.com/jgm/pandoc-citeproc\".\"0.17\" = \"0dxx8cp2xndpw3jwiawch2dkrkp15mil7pyx7dvd810pwc22pm2q\"; }; }; in pandoc.components.exes.pandoc","title":"Handling git repositories in projects"},{"location":"tutorials/source-repository-hashes/#handling-git-repositories-in-projects","text":"Both stack.yaml and cabal.project files can contain references to git repositories containing the version of a particular package that we wish to use. This is mostly handled automatically by nix-tools and haskell.nix however when we want to use a nix system that is configured to use restricted mode (typically hydra) it will need additional hashes for the referenced repositories. When using project , cabalProject or stackProject functions you can include the hash needed in a comment. To calculate the hash use nix-prefetch-git : $ nix-prefetch-git https://github.com/input-output-hk/haskell.nix.git bc01ebc05a8105035c9449943046b46c8364b932 ... { \"url\": \"https://github.com/input-output-hk/haskell.nix.git\", \"rev\": \"bc01ebc05a8105035c9449943046b46c8364b932\", \"date\": \"2019-05-30T13:13:18+08:00\", \"sha256\": \"003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z\", \"fetchSubmodules\": false }","title":"Handling git repositories in projects"},{"location":"tutorials/source-repository-hashes/#cabalproject","text":"Add a --sha256 comment to the cabal.project file: source-repository-package type: git location: https://github.com/input-output-hk/haskell.nix.git tag: bc01ebc05a8105035c9449943046b46c8364b932 subdir: test/cabal-simple --sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z","title":"Cabal.project"},{"location":"tutorials/source-repository-hashes/#stack","text":"Add a # nix-sha256 comment to the stack.yaml file: extra-deps: - git: https://github.com/input-output-hk/haskell.nix.git commit: bc01ebc05a8105035c9449943046b46c8364b932 subdirs: - test/cabal-simple # nix-sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z","title":"Stack"},{"location":"tutorials/source-repository-hashes/#avoiding-modifying-cabalproject-and-stackyaml","text":"In some cases we cannot modify the cabal.project or stack.yaml file to add sha256 comments. As an alternative we can pass in a sha256map . For instance, pandoc includes a cabal.project file on hackage which includes a source-repository-package stanza for pandoc-citeproc : { haskell-nix, testSrc } : let pandoc = haskell-nix.hackage-package { name = \"pandoc\"; version = \"2.9.2.1\"; index-state = \"2020-04-15T00:00:00Z\"; # Function that returns a sha256 string by looking up the location # and tag in a nested attrset sha256map = { \"https://github.com/jgm/pandoc-citeproc\".\"0.17\" = \"0dxx8cp2xndpw3jwiawch2dkrkp15mil7pyx7dvd810pwc22pm2q\"; }; }; in pandoc.components.exes.pandoc","title":"Avoiding modifying cabal.project and stack.yaml"}]}