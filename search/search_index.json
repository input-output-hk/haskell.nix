{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"haskell.nix haskell.nix is an alternative Haskell infrastructure for nixpkgs. See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison. Motivation Why do we need another Haskell infrastructure for nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? These are good questions. And it boils down to the following reasons for us to embark on a new infrastructure: first class support for cross compilation first class support for package sets component level control when building packages reduction of dontCheck for cyclic dependencies reducing build times by building libraries and tests in parallel more logic encoded in nix expressions decoupling of Haskell and nixpkgs cross compilation nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time. package sets We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides its own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set. component level control The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue. cyclic dependencies The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components. build times The Haskell builder in nixpkgs builds a package sequentially, first the library then the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized your build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum. more logic in nix The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date. decoupling Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"Introduction"},{"location":"#haskellnix","text":"haskell.nix is an alternative Haskell infrastructure for nixpkgs. See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison.","title":"haskell.nix"},{"location":"#motivation","text":"Why do we need another Haskell infrastructure for nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? These are good questions. And it boils down to the following reasons for us to embark on a new infrastructure: first class support for cross compilation first class support for package sets component level control when building packages reduction of dontCheck for cyclic dependencies reducing build times by building libraries and tests in parallel more logic encoded in nix expressions decoupling of Haskell and nixpkgs","title":"Motivation"},{"location":"#cross-compilation","text":"nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time.","title":"cross compilation"},{"location":"#package-sets","text":"We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides its own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set.","title":"package sets"},{"location":"#component-level-control","text":"The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue.","title":"component level control"},{"location":"#cyclic-dependencies","text":"The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components.","title":"cyclic dependencies"},{"location":"#build-times","text":"The Haskell builder in nixpkgs builds a package sequentially, first the library then the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized your build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum.","title":"build times"},{"location":"#more-logic-in-nix","text":"The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date.","title":"more logic in nix"},{"location":"#decoupling","text":"Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"decoupling"},{"location":"architecture/","text":"Architecture There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |--- | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '-- .----------. -' .--------------. | | plan-to-nix |---- | plan.nix |------.--- | pkgs.nix | --- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |--- | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram nix-tools nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix . haskell.nix Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own. hackage.nix hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage. stackage.nix stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"Architecture"},{"location":"architecture/#architecture","text":"There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |--- | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '-- .----------. -' .--------------. | | plan-to-nix |---- | plan.nix |------.--- | pkgs.nix | --- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |--- | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram","title":"Architecture"},{"location":"architecture/#nix-tools","text":"nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix .","title":"nix-tools"},{"location":"architecture/#haskellnix","text":"Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own.","title":"haskell.nix"},{"location":"architecture/#hackagenix","text":"hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage.","title":"hackage.nix"},{"location":"architecture/#stackagenix","text":"stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"stackage.nix"},{"location":"changelog/","text":"This file contains a summary of changes to Haskell.nix and nix-tools that will impact users. October 12, 2019 shellFor no longer sets CABAL_CONFIG by default. This avoids surprising users, but means that Cabal may select a plan which is different to your Haskell.nix package set. If you would like the old behaviour, use shellFor { exactDeps = true; } . August 9, 2019 Add the haskellLib.collectComponents function. June 21, 2019 Add ghcWithPackages and ghcWithHoogle to hsPkgs ( documentation . Benchmark components can now build successfully. Reduced the closure bloat of nix-tools, and added closure size limit to CI. Added more reference documentation and set up auto-generated documentation for Module Options . Miscellaneous bug fixes. June 7, 2019 Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages. May 29, 2019 Added shellFor function to package set. May 28, 2019 Added snaphots and haskellPackages attributes to the Haskell.nix top-level. May 22, 2019 Add the cleanSourceHaskell utility function to the Haskell.nix top-level. May 21, 2019 Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo. May 20, 2019 Remove Travis CI in favour of Buildkite. May 17, 2019 Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually. Mar 15, 2019 overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"ChangeLog"},{"location":"changelog/#october-12-2019","text":"shellFor no longer sets CABAL_CONFIG by default. This avoids surprising users, but means that Cabal may select a plan which is different to your Haskell.nix package set. If you would like the old behaviour, use shellFor { exactDeps = true; } .","title":"October 12, 2019"},{"location":"changelog/#august-9-2019","text":"Add the haskellLib.collectComponents function.","title":"August 9, 2019"},{"location":"changelog/#june-21-2019","text":"Add ghcWithPackages and ghcWithHoogle to hsPkgs ( documentation . Benchmark components can now build successfully. Reduced the closure bloat of nix-tools, and added closure size limit to CI. Added more reference documentation and set up auto-generated documentation for Module Options . Miscellaneous bug fixes.","title":"June 21, 2019"},{"location":"changelog/#june-7-2019","text":"Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages.","title":"June 7, 2019"},{"location":"changelog/#may-29-2019","text":"Added shellFor function to package set.","title":"May 29, 2019"},{"location":"changelog/#may-28-2019","text":"Added snaphots and haskellPackages attributes to the Haskell.nix top-level.","title":"May 28, 2019"},{"location":"changelog/#may-22-2019","text":"Add the cleanSourceHaskell utility function to the Haskell.nix top-level.","title":"May 22, 2019"},{"location":"changelog/#may-21-2019","text":"Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo.","title":"May 21, 2019"},{"location":"changelog/#may-20-2019","text":"Remove Travis CI in favour of Buildkite.","title":"May 20, 2019"},{"location":"changelog/#may-17-2019","text":"Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually.","title":"May 17, 2019"},{"location":"changelog/#mar-15-2019","text":"overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"Mar 15, 2019"},{"location":"iohk-nix/","text":"IOHK's nix tooling iohk-nix iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval iohk_nix ; in if try.success then builtins.trace using host iohk_nix try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = ${spec.url}/archive/${spec.rev}.tar.gz ; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { url : https://github.com/input-output-hk/iohk-nix , rev : c92f0119ef5814b0ed1f445c2fdcf8894e326294 , sha256 : 05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm , fetchSubmodules : false } nix/pkgs.nix { pkgs ? import nixpkgs {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"IOHKs nix library"},{"location":"iohk-nix/#iohks-nix-tooling","text":"","title":"IOHK's nix tooling"},{"location":"iohk-nix/#iohk-nix","text":"iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval iohk_nix ; in if try.success then builtins.trace using host iohk_nix try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = ${spec.url}/archive/${spec.rev}.tar.gz ; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { url : https://github.com/input-output-hk/iohk-nix , rev : c92f0119ef5814b0ed1f445c2fdcf8894e326294 , sha256 : 05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm , fetchSubmodules : false } nix/pkgs.nix { pkgs ? import nixpkgs {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"iohk-nix"},{"location":"user-guide/","text":"User Guide Haskell.nix can be use for two different use cases: Use 1 : to build a specific package from hackage or a stackage lts or nightly set. To build a package, say lens , from a stackage snapshot, say lts-13.28 , you could run nix build '(with import nixpkgs (import ./.); haskell-nix.snapshots. lts-13.28 ).lens.components.library' which would build the lens library component from the lens package as fixed by the lts-13.28 stackage snapshot. To build any package from hackage, say lens , in version, say 4.17.1, you could run nix build '(with import nixpkgs (import ./.); (haskell-nix.hackage-package { name = lens ; version = 4.17.1 ; })).components.library' which would build the lens library component from the lens-4.17.1 package from hackage. The dependencies would be solved against the most recent hackage-index-state that comes via the hackage.nix pin with your haskell.nix checkout. A specific one can be specified as well: nix build '(with import nixpkgs (import ./.); (haskell-nix.hackage-package { name = lens ; version = 4.17.1 ; index-state = 2019-07-14T00:00:00Z ; })).components.library' which would use the hackage index as of 2019-07-14T00:00:00Z to produce a build plan for the lens-4.17.1 package. Use 2 : to build a stack or cabal project. So you want to use Haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expression. Getting a copy of the nix-tools (and potentially the Haskell.nix source), will then equip us to produce derivations that we can nix build . Installing nix-tools To build the latest nix-tools and store the result at ./nt , run: nix build '(with import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)); haskell-nix.nix-tools)' --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt Getting the Haskell.nix source (optional) The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . haskell-nix.nix-tools --out-link nt Using Haskell.nix with your project The easiest way to get a hold of Haskell.nix is with fetchTarball . import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)) Using your cabal.project file If your project has a cabal.project you can add a default.nix like this: { pkgs ? import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)) , haskellCompiler ? ghc865 }: pkgs.haskell-nix.cabalProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; ghc = pkgs.buildPackages.pkgs.haskell-nix.compiler.${haskellCompiler}; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `cabal.project` # ]; # modules = [ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `cabal.project` instead # # (`plan-to-nix` will include them as defaults). # ]; } Note: The cleanGit call will exclude any files not in the index file in the local .git directory. This is extremely useful as it avoids unwanted builds (for instance when the contents of dist-newstyle are modified by cabal). It is important that src is the root directory of the repo (so cleanGit can find the .git directory). If the project is not at the root of the repo, then also pass subDir to cleanGit with the location of the project relative to src as a string. For example: src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; subDir = subdir/another-subdir ; }; You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello For interactive development you can run: nix-shell -A shellFor The resulting shell will include all the dependencies of the local packages listed in your cabal.project file (but it will not build those local packages). Inside the shell use cabal new-build and cabal new-repl to work on the cabal project as you normally would. They will use the packages provided by nix whenever possible. It is a good idea to add write-ghc-environment-files: never to your cabal.project file to prevent unwanted .ghc.environment.* files (they will prevent subsequent nix-shell invocations from working properly). Adding an index-state to your cabal.project can pin the plan used so that the same packages will be built each time (until you change the index-state or one of the constraints in your local .cabal files). Using your stack.yaml file If your project has a stack.yaml you can add a default.nix like this: { pkgs ? import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)) }: pkgs.haskell-nix.stackProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `stack.yaml` # ]; # modules = [ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `stack.yaml` instead # # (`stack-to-nix` will include them as defaults). # ]; } You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello Pinning the Haskell.nix version For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin Haskell.nix (as you would pin Nixpkgs). This will make your builds reproducable, more predictable, and faster (because the fixed version is cached). One way of doing this is to use nix-prefetch-git to get a JSON file with a revision and SHA-256 hash of Haskell.nix . $ nix-prefetch-git --quiet https://github.com/input-output-hk/haskell.nix | tee haskell-nix-src.json { url : https://github.com/input-output-hk/haskell.nix , rev : f1a94a4c82a2ab999a67c3b84269da78d89f0075 , date : 2019-06-05T01:06:12+00:00 , sha256 : 0ggxsppjlb6q6a83y12cwgrdnqnw1s128rpibgzs5p1966bdfqla , fetchSubmodules : false } (The tee command is just to show you the result.) Use the following expression to import that version: { nixpkgs ? nixpkgs }: let spec = builtins.fromJSON (builtins.readFile ./haskell-nix-src.json); haskell-nix-src = (import nixpkgs {}).fetchgit { name = haskell-lib ; inherit (spec) url rev sha256 fetchSubmodules; }; in import nixpkgs (import haskell-nix-src) There are other possible schemes for pinning. See haskell.nix/lib/fetch-external.nix , the niv tool, or the Nix Flakes proposal. Overriding the Hackage version Sometimes you might want to use a chosen version of Haskell.nix with a recent update of Hackage or Stackage. This can be done with JSON pins: nix-prefetch-git https://github.com/input-output-hk/hackage.nix | tee hackage-src.json nix-prefetch-git https://github.com/input-output-hk/stackage.nix | tee stackage-src.json The resulting JSON files will correspond to the latest revision of hackage.nix and stackage.nix . See Architecture for more information about how these Git repositories correspond to the actual Hackage and Stackage. { pkgs ? import nixpkgs (haskellNixArgs // { overlays = haskellNixArgs.overlays ++ [ (self: super: { haskell-nix = super.haskell-nix // { hackageSourceJSON = ./hackage-src.json; stackageSourceJSON = ./stackage-src.json; }; })]; }) , haskellNixArgs ? import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) }: pkgs Using nix repl It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { nixpkgs ? nixpkgs }: rec { haskell = import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)); pkgNames = haskell.pkgs.lib.attrNames haskell.haskell-nix.snapshots. lts-13.18 ; } Load the example file: $ nix repl ' nixpkgs ' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading ' nixpkgs '... Added 10403 variables. Loading 'example2.nix'... Added 2 variables. nix-repl lib.take 5 pkgNames [ ALUT ANum Allure Boolean BoundedChan ] nix-repl Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"General"},{"location":"user-guide/#user-guide","text":"Haskell.nix can be use for two different use cases:","title":"User Guide"},{"location":"user-guide/#use-1-to-build-a-specific-package-from-hackage-or-a-stackage-lts-or-nightly-set","text":"To build a package, say lens , from a stackage snapshot, say lts-13.28 , you could run nix build '(with import nixpkgs (import ./.); haskell-nix.snapshots. lts-13.28 ).lens.components.library' which would build the lens library component from the lens package as fixed by the lts-13.28 stackage snapshot. To build any package from hackage, say lens , in version, say 4.17.1, you could run nix build '(with import nixpkgs (import ./.); (haskell-nix.hackage-package { name = lens ; version = 4.17.1 ; })).components.library' which would build the lens library component from the lens-4.17.1 package from hackage. The dependencies would be solved against the most recent hackage-index-state that comes via the hackage.nix pin with your haskell.nix checkout. A specific one can be specified as well: nix build '(with import nixpkgs (import ./.); (haskell-nix.hackage-package { name = lens ; version = 4.17.1 ; index-state = 2019-07-14T00:00:00Z ; })).components.library' which would use the hackage index as of 2019-07-14T00:00:00Z to produce a build plan for the lens-4.17.1 package.","title":"Use 1 : to build a specific package from hackage or a stackage lts or nightly set."},{"location":"user-guide/#use-2-to-build-a-stack-or-cabal-project","text":"So you want to use Haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expression. Getting a copy of the nix-tools (and potentially the Haskell.nix source), will then equip us to produce derivations that we can nix build .","title":"Use 2 : to build a stack or cabal project."},{"location":"user-guide/#installing-nix-tools","text":"To build the latest nix-tools and store the result at ./nt , run: nix build '(with import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)); haskell-nix.nix-tools)' --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt","title":"Installing nix-tools"},{"location":"user-guide/#getting-the-haskellnix-source-optional","text":"The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . haskell-nix.nix-tools --out-link nt","title":"Getting the Haskell.nix source (optional)"},{"location":"user-guide/#using-haskellnix-with-your-project","text":"The easiest way to get a hold of Haskell.nix is with fetchTarball . import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz))","title":"Using Haskell.nix with your project"},{"location":"user-guide/#using-your-cabalproject-file","text":"If your project has a cabal.project you can add a default.nix like this: { pkgs ? import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)) , haskellCompiler ? ghc865 }: pkgs.haskell-nix.cabalProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; ghc = pkgs.buildPackages.pkgs.haskell-nix.compiler.${haskellCompiler}; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `cabal.project` # ]; # modules = [ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `cabal.project` instead # # (`plan-to-nix` will include them as defaults). # ]; } Note: The cleanGit call will exclude any files not in the index file in the local .git directory. This is extremely useful as it avoids unwanted builds (for instance when the contents of dist-newstyle are modified by cabal). It is important that src is the root directory of the repo (so cleanGit can find the .git directory). If the project is not at the root of the repo, then also pass subDir to cleanGit with the location of the project relative to src as a string. For example: src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; subDir = subdir/another-subdir ; }; You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello For interactive development you can run: nix-shell -A shellFor The resulting shell will include all the dependencies of the local packages listed in your cabal.project file (but it will not build those local packages). Inside the shell use cabal new-build and cabal new-repl to work on the cabal project as you normally would. They will use the packages provided by nix whenever possible. It is a good idea to add write-ghc-environment-files: never to your cabal.project file to prevent unwanted .ghc.environment.* files (they will prevent subsequent nix-shell invocations from working properly). Adding an index-state to your cabal.project can pin the plan used so that the same packages will be built each time (until you change the index-state or one of the constraints in your local .cabal files).","title":"Using your cabal.project file"},{"location":"user-guide/#using-your-stackyaml-file","text":"If your project has a stack.yaml you can add a default.nix like this: { pkgs ? import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)) }: pkgs.haskell-nix.stackProject { src = pkgs.haskell-nix.haskellLib.cleanGit { src = ./.; }; # pkg-def-extras = [ # # Additional packages ontop of all those listed in `stack.yaml` # ]; # modules = [ # # Specific package overrides would go here for example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # # It may be better to set flags in `stack.yaml` instead # # (`stack-to-nix` will include them as defaults). # ]; } You can build a component from your project with nix-build (in this case the hello executable in a helloworld package): nix-build -A helloworld.components.exes.hello","title":"Using your stack.yaml file"},{"location":"user-guide/#pinning-the-haskellnix-version","text":"For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin Haskell.nix (as you would pin Nixpkgs). This will make your builds reproducable, more predictable, and faster (because the fixed version is cached). One way of doing this is to use nix-prefetch-git to get a JSON file with a revision and SHA-256 hash of Haskell.nix . $ nix-prefetch-git --quiet https://github.com/input-output-hk/haskell.nix | tee haskell-nix-src.json { url : https://github.com/input-output-hk/haskell.nix , rev : f1a94a4c82a2ab999a67c3b84269da78d89f0075 , date : 2019-06-05T01:06:12+00:00 , sha256 : 0ggxsppjlb6q6a83y12cwgrdnqnw1s128rpibgzs5p1966bdfqla , fetchSubmodules : false } (The tee command is just to show you the result.) Use the following expression to import that version: { nixpkgs ? nixpkgs }: let spec = builtins.fromJSON (builtins.readFile ./haskell-nix-src.json); haskell-nix-src = (import nixpkgs {}).fetchgit { name = haskell-lib ; inherit (spec) url rev sha256 fetchSubmodules; }; in import nixpkgs (import haskell-nix-src) There are other possible schemes for pinning. See haskell.nix/lib/fetch-external.nix , the niv tool, or the Nix Flakes proposal.","title":"Pinning the Haskell.nix version"},{"location":"user-guide/#overriding-the-hackage-version","text":"Sometimes you might want to use a chosen version of Haskell.nix with a recent update of Hackage or Stackage. This can be done with JSON pins: nix-prefetch-git https://github.com/input-output-hk/hackage.nix | tee hackage-src.json nix-prefetch-git https://github.com/input-output-hk/stackage.nix | tee stackage-src.json The resulting JSON files will correspond to the latest revision of hackage.nix and stackage.nix . See Architecture for more information about how these Git repositories correspond to the actual Hackage and Stackage. { pkgs ? import nixpkgs (haskellNixArgs // { overlays = haskellNixArgs.overlays ++ [ (self: super: { haskell-nix = super.haskell-nix // { hackageSourceJSON = ./hackage-src.json; stackageSourceJSON = ./stackage-src.json; }; })]; }) , haskellNixArgs ? import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) }: pkgs","title":"Overriding the Hackage version"},{"location":"user-guide/#using-nix-repl","text":"It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { nixpkgs ? nixpkgs }: rec { haskell = import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz)); pkgNames = haskell.pkgs.lib.attrNames haskell.haskell-nix.snapshots. lts-13.18 ; } Load the example file: $ nix repl ' nixpkgs ' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading ' nixpkgs '... Added 10403 variables. Loading 'example2.nix'... Added 2 variables. nix-repl lib.take 5 pkgNames [ ALUT ANum Allure Boolean BoundedChan ] nix-repl Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"Using nix repl"},{"location":"dev/dev-architecture/","text":"Developer Architecture Overview This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble. Packages haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { library = { depends = [ ... ]; }; exes = { ... = { depends = [ ... ]; }; ... }; sublibs = { ... = { depends = [ ... ]; }; ... }; tests = { ... = { depends = [ ... ]; }; ... }; benchmarks = { ... = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix . Plans Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { $pkg .revision = hackage.$pkg.$version.revisions.default; $pkg .flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = 8.4.4 ; nix-name = ghc844 ; packages = { binary = 0.8.5.1 ; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section. Package Sets (of derivations) We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ). Component builder To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Architecture"},{"location":"dev/dev-architecture/#developer-architecture-overview","text":"This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble.","title":"Developer Architecture Overview"},{"location":"dev/dev-architecture/#packages","text":"haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { library = { depends = [ ... ]; }; exes = { ... = { depends = [ ... ]; }; ... }; sublibs = { ... = { depends = [ ... ]; }; ... }; tests = { ... = { depends = [ ... ]; }; ... }; benchmarks = { ... = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix .","title":"Packages"},{"location":"dev/dev-architecture/#plans","text":"Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { $pkg .revision = hackage.$pkg.$version.revisions.default; $pkg .flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = 8.4.4 ; nix-name = ghc844 ; packages = { binary = 0.8.5.1 ; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section.","title":"Plans"},{"location":"dev/dev-architecture/#package-sets-of-derivations","text":"We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ).","title":"Package Sets (of derivations)"},{"location":"dev/dev-architecture/#component-builder","text":"To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Component builder"},{"location":"dev/maintainer-scripts/","text":"Updating Hackage and Stackage Nix expressions The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Maintainer Scripts"},{"location":"dev/maintainer-scripts/#updating-hackage-and-stackage-nix-expressions","text":"The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Updating Hackage and Stackage Nix expressions"},{"location":"dev/nixpkgs-pin/","text":"Haskell.nix Nixpkgs Pin Haskell.nix contains a Nixpkgs pin in nixpkgs/github.json . This is the version of Nixpkgs used for builds of nix-tools and running the tests. To use haskell.nix the config and overlays need to be applied to Nixpkgs. Users should probably pin a suitable version of nixpkgs, although things might not work for them if their Nixpkgs version is too different. We aim to keep this pin somewhere on a channel of the Nixpkgs latest stable release . That is currently 19.09. We also execute tests on MacOS (darwin). The darwin channel is usually behind the NixOS channel. So we choose the nixpkgs-19.09-darwin channel: nix-prefetch-git https://github.com/NixOS/nixpkgs-channels refs/heads/nixpkgs-19.09-darwin Keep the URL in github.json pointing at https://github.com/NixOS/nixpkgs . Case matters because the Hydra trusted URL whitelist is case-sensitive.","title":"Nixpkgs Pin"},{"location":"dev/nixpkgs-pin/#haskellnix-nixpkgs-pin","text":"Haskell.nix contains a Nixpkgs pin in nixpkgs/github.json . This is the version of Nixpkgs used for builds of nix-tools and running the tests. To use haskell.nix the config and overlays need to be applied to Nixpkgs. Users should probably pin a suitable version of nixpkgs, although things might not work for them if their Nixpkgs version is too different. We aim to keep this pin somewhere on a channel of the Nixpkgs latest stable release . That is currently 19.09. We also execute tests on MacOS (darwin). The darwin channel is usually behind the NixOS channel. So we choose the nixpkgs-19.09-darwin channel: nix-prefetch-git https://github.com/NixOS/nixpkgs-channels refs/heads/nixpkgs-19.09-darwin Keep the URL in github.json pointing at https://github.com/NixOS/nixpkgs . Case matters because the Hydra trusted URL whitelist is case-sensitive.","title":"Haskell.nix Nixpkgs Pin"},{"location":"dev/pkg-map/","text":"Mapping non-Haskell dependencies to Nixpkgs Cabal files may contain dependencies to external non-Haskell dependencies via: * build-tool-depends * pkgconfig-depends . * frameworks * extra-libraries If there is a pkgs attribute in Nixpkgs that matches the name given in the Cabal file, then it will be added as a dependency (see the output of cabal-to-nix ). Otherwise, there needs to be a mapping from Cabal file names (decided by the package author) to Nix package identifiers. Nixpkgs overlay The user may solve it by themself by overriding Nixpkgs and adding a package alias. For example: nixpkgs.overlays = [ (self: super: { icuuc = self.icu; icui18n = self.icu; icudata = self.icu; }) ]; Haskell component/package configuration This is not implemented yet, tracked by issue #198 . Mapping in Haskell.nix Alternatively, if the name is commonly used, an alias can be added to the Haskell.nix sources, so that it's solved for all users. lib/pkgconf-nixpkgs-map.nix - for pkgconfig-depends lib/system-nixpkgs-map.nix - for build-tool-depends , frameworks , extra-libraries , etc. Open a PR Please go ahead and open a pull request to improve the package mappings.","title":"Mapping non-Haskell dependencies to Nixpkgs"},{"location":"dev/pkg-map/#mapping-non-haskell-dependencies-to-nixpkgs","text":"Cabal files may contain dependencies to external non-Haskell dependencies via: * build-tool-depends * pkgconfig-depends . * frameworks * extra-libraries If there is a pkgs attribute in Nixpkgs that matches the name given in the Cabal file, then it will be added as a dependency (see the output of cabal-to-nix ). Otherwise, there needs to be a mapping from Cabal file names (decided by the package author) to Nix package identifiers.","title":"Mapping non-Haskell dependencies to Nixpkgs"},{"location":"dev/pkg-map/#nixpkgs-overlay","text":"The user may solve it by themself by overriding Nixpkgs and adding a package alias. For example: nixpkgs.overlays = [ (self: super: { icuuc = self.icu; icui18n = self.icu; icudata = self.icu; }) ];","title":"Nixpkgs overlay"},{"location":"dev/pkg-map/#haskell-componentpackage-configuration","text":"This is not implemented yet, tracked by issue #198 .","title":"Haskell component/package configuration"},{"location":"dev/pkg-map/#mapping-in-haskellnix","text":"Alternatively, if the name is commonly used, an alias can be added to the Haskell.nix sources, so that it's solved for all users. lib/pkgconf-nixpkgs-map.nix - for pkgconfig-depends lib/system-nixpkgs-map.nix - for build-tool-depends , frameworks , extra-libraries , etc. Open a PR Please go ahead and open a pull request to improve the package mappings.","title":"Mapping in Haskell.nix"},{"location":"dev/removing-with-package-wrapper/","text":"ghcWithPackages wrapper removal The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone. Plain ghc When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well. ghc-pkg The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set. Setup.hs When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages. cabal new-build Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"Removing withPackage wrapper"},{"location":"dev/removing-with-package-wrapper/#ghcwithpackages-wrapper-removal","text":"The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone.","title":"ghcWithPackages wrapper removal"},{"location":"dev/removing-with-package-wrapper/#plain-ghc","text":"When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well.","title":"Plain ghc"},{"location":"dev/removing-with-package-wrapper/#ghc-pkg","text":"The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set.","title":"ghc-pkg"},{"location":"dev/removing-with-package-wrapper/#setuphs","text":"When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages.","title":"Setup.hs"},{"location":"dev/removing-with-package-wrapper/#cabal-new-build","text":"Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"cabal new-build"},{"location":"dev/tests/","text":"Haskell infrastructure test cases To build the test cases, run from the test directory: nix-build --no-out-link default.nix To run all tests (includes impure tests), use the script: ./tests.sh Generated code If you change the test Cabal files or need to regenerate the code with nix-tools, then see regen.nix . Run it like this: $(nix-build --no-out-link regen.nix)","title":"Test Suite"},{"location":"dev/tests/#haskell-infrastructure-test-cases","text":"To build the test cases, run from the test directory: nix-build --no-out-link default.nix To run all tests (includes impure tests), use the script: ./tests.sh","title":"Haskell infrastructure test cases"},{"location":"dev/tests/#generated-code","text":"If you change the test Cabal files or need to regenerate the code with nix-tools, then see regen.nix . Run it like this: $(nix-build --no-out-link regen.nix)","title":"Generated code"},{"location":"reference/commands/","text":"stack-to-nix stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: stack.yaml ) --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: .stack-to-nix.cache ) -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache (The open issue is #57 ). plan-to-nix plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: dist-newstyle/cache/plan.json ) --cabal-project FILE Override path to cabal.project (default: cabal.project ) --cache FILE Dependency cache file (default: .nix-tools.cache ) -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Note If you find that there are missing files which should have been generated, remove .nix-tools.cache (The open issue is #57 ). cabal-to-nix Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"Command-line tools"},{"location":"reference/commands/#stack-to-nix","text":"stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: stack.yaml ) --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: .stack-to-nix.cache ) -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache (The open issue is #57 ).","title":"stack-to-nix"},{"location":"reference/commands/#plan-to-nix","text":"plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: dist-newstyle/cache/plan.json ) --cabal-project FILE Override path to cabal.project (default: cabal.project ) --cache FILE Dependency cache file (default: .nix-tools.cache ) -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Note If you find that there are missing files which should have been generated, remove .nix-tools.cache (The open issue is #57 ).","title":"plan-to-nix"},{"location":"reference/commands/#cabal-to-nix","text":"Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"cabal-to-nix"},{"location":"reference/library/","text":"Haskell.nix contains a library of functions for creating buildable package sets from their Nix expression descriptions. The library is what you get when importing Haskell.nix . It might be helpful to load the library in the Nix REPL to test things. Types \u2014 the kinds of data that you will encounter working with Haskell.nix . Top-level attributes \u2014 Functions and derivations defined in the Haskell.nix attrset. Package-set functions \u2014 Helper functions defined on the hsPkgs package set. Types Package Set The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = X.Y.Z ; nix-name = ghcXYZ ; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset Haskell Package description The Haskell package descriptions are values of the pkgSet.config.packages attrset. These are not derivations, but just the configuration for building an individual package. The configuration options are described under packages. name in Module options . Component description The component descriptions are values of the pkgSet.config.packages. package .components attrset. These are not derivations, but just the configuration for building an individual component. The configuration options are described under packages. name .components.* in Module options . Haskell Package In Haskell.nix , a Haskell package is a derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; all = COMPONENT; } Component In Haskell.nix , a component is a derivation corresponding to a Cabal component of a package. Haskell.nix also defines a special all component, which is the union of all components in the package. Identifier A package identifier is an attrset pair of name and version . Extras Extras allow adding more packages to the package set. These will be functions taking a single parameter hackage . They should return an attrset of package descriptions. Modules Modules are the primary method of configuring building of the package set. They are either: an attrset containing option declarations , or a function that returns an attrset containing option declarations. If using the function form of a module, the following named parameters will be passed to it: Argument Type Description haskellLib attrset The haskellLib utility functions. pkgs The Nixpkgs collection. pkgconfPkgs A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this) buildModules config options Top-level attributes mkStackPkgSet Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkCabalProjectPkgSet Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkPkgSet This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet snapshots This is an attrset of hsPkgs packages from Stackage. haskellPackages A hsPkgs package set, which is one of the recent LTS Haskell releases from snapshots . The chosen LTS is updated occasionally in Haskell.nix , though a manual process. nix-tools A derivation containing the nix-tools command-line tools . callStackToNix Runs stack-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkStackPkgSet { stack-pkgs = (importAndFilterProject (callStackToNix { src = ./.; })).pkgs; pkg-def-extras = []; modules = []; }; callCabalProjectToNix Runs cabal new-configure and plan-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkCabalProjectPkgSet { plan-pkgs = (importAndFilterProject (callCabalProjectToNix { index-state = 2019-04-30T00:00:00Z ; src = ./.; })).pkgs; Argument Type Description name String Optional name for better error messages. src Path Location of the cabal project files. index-state Timestamp Optional hackage index-state, eg. \"2019-10-10T00:00:00Z\". index-sha256 Sha256 Optional hash of the truncated hackage index-state. plan-sha256 Sha256 Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation). cabalProject Path Optional cabal project file (defaults to \"${src}/cabal.project\"). ghc Optional ghc to use nix-tools Optional nix-tools to use hpack Optional hpack to use cabal-install Optional cabal-install to use importAndFilterProject Imports from a derivation created by callStackToNix or callCabalProjectToNix . The result is an attrset with the following values: Attribute Type Description pkgs attrset that can be passed to mkStackPkgSet (as stack-pkgs ) or mkCabalProjectPkgSet (as plan-pkgs ). nix this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra). hackage stackage fetchExternal cleanSourceHaskell haskellLib Assorted functions for operating on Haskell.nix data. This is distinct from pkgs.haskell.lib in the current Nixpkgs Haskell Infrastructure. collectComponents Extracts a selection of components from a Haskell package set . This can be used to filter out all test suites or benchmarks of your project, so that they can be built in Hydra. collectComponents = group: packageSel: haskellPackages: ... Argument Type Description group String A sub-component type . packageSel A function Package - Bool A predicate to filter packages with. haskellPackages Package set All packages in the build. Return value : a recursive attrset mapping package names \u2192 component names \u2192 components. Example : tests = collectComponents tests (package: package.identifier.name == mypackage ) hsPkgs; Will result in moving derivations from hsPkgs.mypackage.components.tests.unit-tests to tests.mypackage.unit-tests . subComponentTypes Sub-component types identify components and are one of: sublibs foreignlibs exes tests benchmarks Package-set functions These functions exist within the hsPkgs package set. shellFor Create a nix-shell development environment for developing one or more packages with ghci or cabal v2-build (but not Stack). shellFor = { packages, withHoogle ? true, exactDeps ? false, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. exactDeps Boolean Prevents the Cabal solver from choosing any package dependency other than what are in the package set. { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation Warning exactDeps = true will set the CABAL_CONFIG environment variable to disable remote package servers. This is a known limitation which we would like to solve. Use exactDeps = false if this is a problem. ghcWithPackages Creates a nix-shell development environment including the given packages selected from this package set. Parameter : a package selection function. Return value : a derivation Example : haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ]) ghcWithHoogle The same as ghcWithPackages , except, a hoogle command with a Hoogle documentation index of the packages will be included in the shell.","title":"Haskell.nix Library"},{"location":"reference/library/#types","text":"","title":"Types"},{"location":"reference/library/#package-set","text":"The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = X.Y.Z ; nix-name = ghcXYZ ; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset","title":"Package Set"},{"location":"reference/library/#haskell-package-description","text":"The Haskell package descriptions are values of the pkgSet.config.packages attrset. These are not derivations, but just the configuration for building an individual package. The configuration options are described under packages. name in Module options .","title":"Haskell Package description"},{"location":"reference/library/#component-description","text":"The component descriptions are values of the pkgSet.config.packages. package .components attrset. These are not derivations, but just the configuration for building an individual component. The configuration options are described under packages. name .components.* in Module options .","title":"Component description"},{"location":"reference/library/#haskell-package","text":"In Haskell.nix , a Haskell package is a derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; all = COMPONENT; }","title":"Haskell Package"},{"location":"reference/library/#component","text":"In Haskell.nix , a component is a derivation corresponding to a Cabal component of a package. Haskell.nix also defines a special all component, which is the union of all components in the package.","title":"Component"},{"location":"reference/library/#identifier","text":"A package identifier is an attrset pair of name and version .","title":"Identifier"},{"location":"reference/library/#extras","text":"Extras allow adding more packages to the package set. These will be functions taking a single parameter hackage . They should return an attrset of package descriptions.","title":"Extras"},{"location":"reference/library/#modules","text":"Modules are the primary method of configuring building of the package set. They are either: an attrset containing option declarations , or a function that returns an attrset containing option declarations. If using the function form of a module, the following named parameters will be passed to it: Argument Type Description haskellLib attrset The haskellLib utility functions. pkgs The Nixpkgs collection. pkgconfPkgs A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this) buildModules config options","title":"Modules"},{"location":"reference/library/#top-level-attributes","text":"","title":"Top-level attributes"},{"location":"reference/library/#mkstackpkgset","text":"Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkStackPkgSet"},{"location":"reference/library/#mkcabalprojectpkgset","text":"Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkCabalProjectPkgSet"},{"location":"reference/library/#mkpkgset","text":"This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet","title":"mkPkgSet"},{"location":"reference/library/#snapshots","text":"This is an attrset of hsPkgs packages from Stackage.","title":"snapshots"},{"location":"reference/library/#haskellpackages","text":"A hsPkgs package set, which is one of the recent LTS Haskell releases from snapshots . The chosen LTS is updated occasionally in Haskell.nix , though a manual process.","title":"haskellPackages"},{"location":"reference/library/#nix-tools","text":"A derivation containing the nix-tools command-line tools .","title":"nix-tools"},{"location":"reference/library/#callstacktonix","text":"Runs stack-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkStackPkgSet { stack-pkgs = (importAndFilterProject (callStackToNix { src = ./.; })).pkgs; pkg-def-extras = []; modules = []; };","title":"callStackToNix"},{"location":"reference/library/#callcabalprojecttonix","text":"Runs cabal new-configure and plan-to-nix and produces the output needed for importAndFilterProject . Example : pkgSet = mkCabalProjectPkgSet { plan-pkgs = (importAndFilterProject (callCabalProjectToNix { index-state = 2019-04-30T00:00:00Z ; src = ./.; })).pkgs; Argument Type Description name String Optional name for better error messages. src Path Location of the cabal project files. index-state Timestamp Optional hackage index-state, eg. \"2019-10-10T00:00:00Z\". index-sha256 Sha256 Optional hash of the truncated hackage index-state. plan-sha256 Sha256 Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation). cabalProject Path Optional cabal project file (defaults to \"${src}/cabal.project\"). ghc Optional ghc to use nix-tools Optional nix-tools to use hpack Optional hpack to use cabal-install Optional cabal-install to use","title":"callCabalProjectToNix"},{"location":"reference/library/#importandfilterproject","text":"Imports from a derivation created by callStackToNix or callCabalProjectToNix . The result is an attrset with the following values: Attribute Type Description pkgs attrset that can be passed to mkStackPkgSet (as stack-pkgs ) or mkCabalProjectPkgSet (as plan-pkgs ). nix this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra).","title":"importAndFilterProject"},{"location":"reference/library/#hackage","text":"","title":"hackage"},{"location":"reference/library/#stackage","text":"","title":"stackage"},{"location":"reference/library/#fetchexternal","text":"","title":"fetchExternal"},{"location":"reference/library/#cleansourcehaskell","text":"","title":"cleanSourceHaskell"},{"location":"reference/library/#haskelllib","text":"Assorted functions for operating on Haskell.nix data. This is distinct from pkgs.haskell.lib in the current Nixpkgs Haskell Infrastructure.","title":"haskellLib"},{"location":"reference/library/#collectcomponents","text":"Extracts a selection of components from a Haskell package set . This can be used to filter out all test suites or benchmarks of your project, so that they can be built in Hydra. collectComponents = group: packageSel: haskellPackages: ... Argument Type Description group String A sub-component type . packageSel A function Package - Bool A predicate to filter packages with. haskellPackages Package set All packages in the build. Return value : a recursive attrset mapping package names \u2192 component names \u2192 components. Example : tests = collectComponents tests (package: package.identifier.name == mypackage ) hsPkgs; Will result in moving derivations from hsPkgs.mypackage.components.tests.unit-tests to tests.mypackage.unit-tests .","title":"collectComponents"},{"location":"reference/library/#subcomponenttypes","text":"Sub-component types identify components and are one of: sublibs foreignlibs exes tests benchmarks","title":"subComponentTypes"},{"location":"reference/library/#package-set-functions","text":"These functions exist within the hsPkgs package set.","title":"Package-set functions"},{"location":"reference/library/#shellfor","text":"Create a nix-shell development environment for developing one or more packages with ghci or cabal v2-build (but not Stack). shellFor = { packages, withHoogle ? true, exactDeps ? false, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. exactDeps Boolean Prevents the Cabal solver from choosing any package dependency other than what are in the package set. { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation Warning exactDeps = true will set the CABAL_CONFIG environment variable to disable remote package servers. This is a known limitation which we would like to solve. Use exactDeps = false if this is a problem.","title":"shellFor"},{"location":"reference/library/#ghcwithpackages","text":"Creates a nix-shell development environment including the given packages selected from this package set. Parameter : a package selection function. Return value : a derivation Example : haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ])","title":"ghcWithPackages"},{"location":"reference/library/#ghcwithhoogle","text":"The same as ghcWithPackages , except, a hoogle command with a Hoogle documentation index of the packages will be included in the shell.","title":"ghcWithHoogle"},{"location":"reference/modules-preamble/","text":"Haskell.nix modules options for packages and components. Undocumented Please help write me. This documentation is generated from Nix sources in the modules subdirectory. The Markdown generation script could also be improved.","title":"Modules preamble"},{"location":"reference/modules/","text":"Haskell.nix modules options for packages and components. Undocumented Please help write me. This documentation is generated from Nix sources in the modules subdirectory. The Markdown generation script could also be improved. Configuration Options enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages This option has no description. Type: attribute set of submodules Declared by: modules/plan.nix packages. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .package.author This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.buildType This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.cleanHpack This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .package.copyright This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.dataDir This option has no description. Type: string Default: \"\" Declared by: modules/plan.nix packages. name .package.dataFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.description This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.detailLevel This option has no description. Type: string Default: \"MinimalDetails\" Declared by: modules/plan.nix packages. name .package.extraDocFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.extraTmpFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.ghcOptions This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .package.homepage This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.identifier.name This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.identifier.version This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.isLocal This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .package.license This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.licenseFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.maintainer This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.setup-depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.specVersion This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.synopsis This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.url This option has no description. Type: string Declared by: modules/plan.nix packages. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .cabal-generator This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all The merged dependencies of all other components Type: submodule Declared by: modules/plan.nix packages. name .components.all.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.all.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.all.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.all.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.all.profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.all.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.all.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.benchmarks This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.benchmarks. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.benchmarks. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.benchmarks. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.benchmarks. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.exes This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.exes. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.exes. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.exes. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.exes. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.exes. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.exes. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.foreignlibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.foreignlibs. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.foreignlibs. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.foreignlibs. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.foreignlibs. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.library This option has no description. Type: null or submodule Default: null Declared by: modules/plan.nix packages. name .components.library.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.library.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.library.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.library.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.library.profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.library.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.library.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.setup This option has no description. Type: null or submodule Default: ` { asmSources = [ ] ; cSources = [ ] ; cmmSources = [ ] ; cxxSources = [ ] ; depends = [ ] ; doExactConfig = false; extraSrcFiles = [ \"Setup.hs\" \"Setup.lhs\" ] ; frameworks = [ ] ; hsSourceDirs = [ \"setup-src\" ] ; includeDirs = [ ] ; jsSources = [ ] ; libs = [ ] ; platforms = null; } ` Declared by: modules/plan.nix packages. name .components.setup.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.setup.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.setup.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.setup.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.setup.profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.setup.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.setup.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.sublibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.sublibs. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.sublibs. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.sublibs. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.sublibs. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.sublibs. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.tests This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.tests. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.tests. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.tests. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.tests. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.tests. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.tests. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .flags This option has no description. Type: attribute set of booleans Declared by: modules/plan.nix packages. name .name This option has no description. Type: string Default: \"\\${config.package.identifier.name}-\\${config.package.identifier.version}\" Declared by: modules/plan.nix packages. name .patches This option has no description. Type: list of unspecified or paths Default: ` [ ] ` Declared by: modules/plan.nix packages. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .revision This option has no description. Type: null or signed integer Default: null Declared by: modules/plan.nix packages. name .revisionSha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .sha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .src This option has no description. Type: path or package Default: ''pkgs.fetchurl { url = \"mirror://hackage/''${config.name}.tar.gz\"; inherit (config) sha256; };'' Declared by: modules/plan.nix packages. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix bootPkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix cabal.compiler This option has no description. Type: unspecified Declared by: modules/cabal.nix cabal.system This option has no description. Type: unspecified Declared by: modules/cabal.nix compiler.packages This option has no description. Type: attribute set of strings Declared by: modules/plan.nix compiler.nix-name This option has no description. Type: string Declared by: modules/plan.nix compiler.version This option has no description. Type: string Declared by: modules/plan.nix configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix ghc.package This option has no description. Type: package Default: \"pkgs.buildPackages.haskell-nix.compiler.\\${config.compiler.nix-name}\" Declared by: modules/hackage.nix hackage.configs This option has no description. Type: unspecified Declared by: modules/hackage.nix hackage.db This option has no description. Type: unspecified Declared by: modules/hackage.nix hsPkgs This option has no description. Type: unspecified Declared by: modules/component-driver.nix nonReinstallablePkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix reinstallableLibGhc Is lib:ghc reinstallable? Type: boolean Default: false Declared by: modules/component-driver.nix setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix","title":"Module options"},{"location":"reference/modules/#configuration-options","text":"enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages This option has no description. Type: attribute set of submodules Declared by: modules/plan.nix packages. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .package.author This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.buildType This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.cleanHpack This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .package.copyright This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.dataDir This option has no description. Type: string Default: \"\" Declared by: modules/plan.nix packages. name .package.dataFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.description This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.detailLevel This option has no description. Type: string Default: \"MinimalDetails\" Declared by: modules/plan.nix packages. name .package.extraDocFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.extraTmpFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.ghcOptions This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .package.homepage This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.identifier.name This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.identifier.version This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.isLocal This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .package.license This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.licenseFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.maintainer This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.setup-depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .package.specVersion This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.synopsis This option has no description. Type: string Declared by: modules/plan.nix packages. name .package.url This option has no description. Type: string Declared by: modules/plan.nix packages. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .cabal-generator This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all The merged dependencies of all other components Type: submodule Declared by: modules/plan.nix packages. name .components.all.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.all.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.all.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.all.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.all.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.all.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.all.profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.all.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.all.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.all.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.benchmarks This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.benchmarks. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.benchmarks. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.benchmarks. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.benchmarks. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.benchmarks. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.benchmarks. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.benchmarks. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.exes This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.exes. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.exes. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.exes. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.exes. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.exes. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.exes. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.exes. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.exes. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.exes. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.foreignlibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.foreignlibs. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.foreignlibs. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.foreignlibs. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.foreignlibs. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.foreignlibs. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.foreignlibs. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.foreignlibs. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.library This option has no description. Type: null or submodule Default: null Declared by: modules/plan.nix packages. name .components.library.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.library.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.library.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.library.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.library.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.library.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.library.profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.library.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.library.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.library.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.setup This option has no description. Type: null or submodule Default: ` { asmSources = [ ] ; cSources = [ ] ; cmmSources = [ ] ; cxxSources = [ ] ; depends = [ ] ; doExactConfig = false; extraSrcFiles = [ \"Setup.hs\" \"Setup.lhs\" ] ; frameworks = [ ] ; hsSourceDirs = [ \"setup-src\" ] ; includeDirs = [ ] ; jsSources = [ ] ; libs = [ ] ; platforms = null; } ` Declared by: modules/plan.nix packages. name .components.setup.enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.setup.cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.setup.doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.setup.extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.setup.postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.setup.preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.setup.profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.setup.setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.setup.testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.setup.testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.sublibs This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.sublibs. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.sublibs. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.sublibs. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.sublibs. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.sublibs. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.sublibs. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.sublibs. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.sublibs. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .components.tests This option has no description. Type: attribute set of submodules Default: ` { } ` Declared by: modules/plan.nix packages. name .components.tests. name .enableExecutableProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .enableLibraryProfiling This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .enableSeparateDataOutput This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .asmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .build-tools This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.tests. name .cSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .cmmSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .cxxSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .depends This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .components.tests. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .components.tests. name .extraSrcFiles This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .frameworks This option has no description. Type: list of packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .hsSourceDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .includeDirs This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .includes This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .jsSources This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .libs This option has no description. Type: list of null or packages Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .mainPath This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .modules This option has no description. Type: list of unspecifieds Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .pkgconfig This option has no description. Type: list of list of packagess Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .platforms This option has no description. Type: null or list of unspecifieds Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .components.tests. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .components.tests. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .components.tests. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .components.tests. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .components.tests. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix packages. name .configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix packages. name .doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix packages. name .doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix packages. name .flags This option has no description. Type: attribute set of booleans Declared by: modules/plan.nix packages. name .name This option has no description. Type: string Default: \"\\${config.package.identifier.name}-\\${config.package.identifier.version}\" Declared by: modules/plan.nix packages. name .patches This option has no description. Type: list of unspecified or paths Default: ` [ ] ` Declared by: modules/plan.nix packages. name .postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix packages. name .profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix packages. name .revision This option has no description. Type: null or signed integer Default: null Declared by: modules/plan.nix packages. name .revisionSha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .sha256 This option has no description. Type: null or string Default: null Declared by: modules/plan.nix packages. name .shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix packages. name .src This option has no description. Type: path or package Default: ''pkgs.fetchurl { url = \"mirror://hackage/''${config.name}.tar.gz\"; inherit (config) sha256; };'' Declared by: modules/plan.nix packages. name .testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix packages. name .testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix bootPkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix buildable This option has no description. Type: boolean Default: true Declared by: modules/plan.nix cabal.compiler This option has no description. Type: unspecified Declared by: modules/cabal.nix cabal.system This option has no description. Type: unspecified Declared by: modules/cabal.nix compiler.packages This option has no description. Type: attribute set of strings Declared by: modules/plan.nix compiler.nix-name This option has no description. Type: string Declared by: modules/plan.nix compiler.version This option has no description. Type: string Declared by: modules/plan.nix configureFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix doCheck This option has no description. Type: boolean Default: false Declared by: modules/plan.nix doCrossCheck Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target. Type: boolean Default: false Declared by: modules/plan.nix doExactConfig This option has no description. Type: boolean Default: false Declared by: modules/plan.nix doHaddock Enable building of the Haddock documentation from the annotated Haskell source code. Type: boolean Default: true Declared by: modules/plan.nix ghc.package This option has no description. Type: package Default: \"pkgs.buildPackages.haskell-nix.compiler.\\${config.compiler.nix-name}\" Declared by: modules/hackage.nix hackage.configs This option has no description. Type: unspecified Declared by: modules/hackage.nix hackage.db This option has no description. Type: unspecified Declared by: modules/hackage.nix hsPkgs This option has no description. Type: unspecified Declared by: modules/component-driver.nix nonReinstallablePkgs This option has no description. Type: list of strings Declared by: modules/component-driver.nix postBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix postUnpack This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preBuild This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preCheck This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preConfigure This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preHaddock This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preInstall This option has no description. Type: null or string Default: null Declared by: modules/plan.nix preUnpack This option has no description. Type: null or strings concatenated with \"\\n\" Default: null Declared by: modules/plan.nix profilingDetail This option has no description. Type: null or string Default: \"exported-functions\" Declared by: modules/plan.nix reinstallableLibGhc Is lib:ghc reinstallable? Type: boolean Default: false Declared by: modules/component-driver.nix setupBuildFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupHaddockFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix setupInstallFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix shellHook Hook to run when entering a shell Type: unspecified Default: \"\" Declared by: modules/plan.nix testFlags This option has no description. Type: list of strings Default: ` [ ] ` Declared by: modules/plan.nix testWrapper A command to run for executing tests in checkPhase, which takes the original test command as its arguments. Type: list of strings Default: ` [ ] ` Example: \"echo\" Declared by: modules/plan.nix","title":"Configuration Options"},{"location":"user-guide/cabal-projects/","text":"Here we will look into how to generate the pkgs.nix file for a cabal.project project. For the full integration see the previous page . Generating package sets for Cabal projects, is slightly more involved, because you need to let Cabal calculate a build plan for the dependencies of your package(s). Generating plan.json To get a plan, you need Cabal and GHC. See the How to install a compiler section of the Nixpkgs Manual for information about how to choose a specific compiler version. Cabal version The minimum Cabal version is 2.4. This version is available in the NixOS 19.03 release. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run cabal new-configure If all goes well, you should now have the file dist-newstyle/cache/plan.json . Specifying the GHC version To use a specific compiler version, replace haskellPackages.ghc with something like haskell-nix.compiler.ghc865 . The given compiler must exist in your Nixpkgs version, of course. See also the Nixpkgs Manual . Using plan-to-nix With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description. Creating the package set Import the generated pkgs.nix and pass to mkCabalPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Cabal Projects"},{"location":"user-guide/cabal-projects/#generating-planjson","text":"To get a plan, you need Cabal and GHC. See the How to install a compiler section of the Nixpkgs Manual for information about how to choose a specific compiler version. Cabal version The minimum Cabal version is 2.4. This version is available in the NixOS 19.03 release. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run cabal new-configure If all goes well, you should now have the file dist-newstyle/cache/plan.json . Specifying the GHC version To use a specific compiler version, replace haskellPackages.ghc with something like haskell-nix.compiler.ghc865 . The given compiler must exist in your Nixpkgs version, of course. See also the Nixpkgs Manual .","title":"Generating plan.json"},{"location":"user-guide/cabal-projects/#using-plan-to-nix","text":"With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description.","title":"Using plan-to-nix"},{"location":"user-guide/cabal-projects/#creating-the-package-set","text":"Import the generated pkgs.nix and pass to mkCabalPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Creating the package set"},{"location":"user-guide/cross-compilation/","text":"Cross compilation of Haskell projects involves building a version of GHC that outputs code for the target platform, and providing builds of all library dependencies for that platform. First, understand how to cross-compile a normal package from Nixpkgs. Matthew Bauer's Beginners' guide to cross compilation in Nixpkgs is a useful resource. Using an example from the guide, this builds GNU Hello for a Raspberry Pi: nix build -f ' nixpkgs ' pkgsCross.raspberryPi.hello We will use the same principle in Haskell.nix \u2014 replacing the normal package set pkgs with a cross-compiling package set pkgsCross.raspberryPi . Raspberry Pi example This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! Hint The above example won't build, but you can try and see, if you like. It will fail on clock-0.7.2 , which needs a patch to build. To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags, adding patches, and so on. Static executables with Musl libc Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ --disable-executable-dynamic --disable-shared --ghc-option=-optl=-pthread --ghc-option=-optl=-static --ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib --ghc-option=-optl=-L${zlib.static}/lib ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this. How to cross-compile your project Set up your project Haskell package set. # default.nix { pkgs ? import nixpkgs {} let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = [ { # You will need to put build fixes here. } ]; }; in pkgSet.config.hsPkgs Apply that package set to the Nixpkgs cross package sets that you are interested in. We are going to expand the pkgs.pkgsCross shortcut to be more explicit. let pkgs = import nixpkgs {} in { shortcut = pkgs.pkgsCross.SYSTEM; actual = import nixpkgs { crossSystem = pkgs.lib.systems.examples.SYSTEM; }; } In the above example, for any SYSTEM , shortcut and actual are the same package set. # release.nix let myProject = import ./default.nix; pkgsNative = import nixpkgs {}; pkgsRaspberryPi = import nixpkgs { crossSystem = pkgsNative.lib.systems.examples.raspberryPi; }; native = myProject { pkgs = pkgsNative; }; crossRaspberryPi = myProject { pkgs = pkgsRaspberryPi; }; in { my-project-native = native.my-project.components.exes.my-project; my-project-raspberry-pi = crossRaspberryPi.my-project.components.exes.my-project; } Try to build it, and apply fixes to the modules list, until there are no errors left.","title":"How to cross-compile your project"},{"location":"user-guide/cross-compilation/#raspberry-pi-example","text":"This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! Hint The above example won't build, but you can try and see, if you like. It will fail on clock-0.7.2 , which needs a patch to build. To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags, adding patches, and so on.","title":"Raspberry Pi example"},{"location":"user-guide/cross-compilation/#static-executables-with-musl-libc","text":"Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ --disable-executable-dynamic --disable-shared --ghc-option=-optl=-pthread --ghc-option=-optl=-static --ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib --ghc-option=-optl=-L${zlib.static}/lib ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this.","title":"Static executables with Musl libc"},{"location":"user-guide/cross-compilation/#how-to-cross-compile-your-project","text":"Set up your project Haskell package set. # default.nix { pkgs ? import nixpkgs {} let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = [ { # You will need to put build fixes here. } ]; }; in pkgSet.config.hsPkgs Apply that package set to the Nixpkgs cross package sets that you are interested in. We are going to expand the pkgs.pkgsCross shortcut to be more explicit. let pkgs = import nixpkgs {} in { shortcut = pkgs.pkgsCross.SYSTEM; actual = import nixpkgs { crossSystem = pkgs.lib.systems.examples.SYSTEM; }; } In the above example, for any SYSTEM , shortcut and actual are the same package set. # release.nix let myProject = import ./default.nix; pkgsNative = import nixpkgs {}; pkgsRaspberryPi = import nixpkgs { crossSystem = pkgsNative.lib.systems.examples.raspberryPi; }; native = myProject { pkgs = pkgsNative; }; crossRaspberryPi = myProject { pkgs = pkgsRaspberryPi; }; in { my-project-native = native.my-project.components.exes.my-project; my-project-raspberry-pi = crossRaspberryPi.my-project.components.exes.my-project; } Try to build it, and apply fixes to the modules list, until there are no errors left.","title":"How to cross-compile your project"},{"location":"user-guide/development/","text":"Haskell.nix also provides reproducible development environments for your Haskell projects. These environments can contain not only GHC and your Haskell package dependencies, but also the required system libraries and build tools. Inside the development shell, you can run commands such as ghc , ghci , or cabal new\u2011build , and they will have all dependencies available. Every dependency will be cached in your Nix store. If you have set up Hydra CI, then your team can share pre-built dependencies. These examples assume that you have created your package set as described in Creating Nix builds for your projects and it exists in a file called default.nix . Note Old-style cabal build and stack builds are not (yet) supported. For example, stack will (by design) download and rebuild all dependencies, even though they are available in the shell. However, if you have a Stack project, you can generate the package set with Haskell.nix, then use cabal new\u2011build to work on it. How to get a development shell for a package Run a nix\u2011shell on components.all of your package. all is a synthetic component whose dependencies are the union of the dependencies of all components in the package. Therefore, you will be able to build the test suites because their dependencies will be included. # shell.nix let hsPkgs = import ./default.nix {}; in hsPkgs.my-package.components.all How to get a development shell for a multi-package project If you have a Cabal or Stack project with multiple packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import nixpkgs {} }: let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a hoogle command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). buildInputs = with pkgs.haskellPackages; [ hlint stylish-haskell ghcid ]; # Prevents cabal from choosing alternate plans, so that # *all* dependencies are provided by Nix. exactDeps = true; } See also: Haskell.nix Library Reference: shellFor How to get a local Hoogle index If you need a local Hoogle for all the dependencies of your project create this file # shell-hoogle.nix let hsPkgs = import ./default.nix {}; in hsPkgs.shellFor { packages = ps: [ps.my-package]; withHoogle = true; } and run nix-shell shell-hoogle.nix --run \"hoogle server --local\" . This will open a local Hoogle server at http://127.0.0.1:8080 . How to get an ad-hoc development shell including certain packages This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages . How to get packages from a certain Stackage snapshot Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.snapshots. lts-13.18 .alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built. Emacs IDE support Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl .","title":"How to create a development environment"},{"location":"user-guide/development/#how-to-get-a-development-shell-for-a-package","text":"Run a nix\u2011shell on components.all of your package. all is a synthetic component whose dependencies are the union of the dependencies of all components in the package. Therefore, you will be able to build the test suites because their dependencies will be included. # shell.nix let hsPkgs = import ./default.nix {}; in hsPkgs.my-package.components.all","title":"How to get a development shell for a package"},{"location":"user-guide/development/#how-to-get-a-development-shell-for-a-multi-package-project","text":"If you have a Cabal or Stack project with multiple packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import nixpkgs {} }: let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a hoogle command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). buildInputs = with pkgs.haskellPackages; [ hlint stylish-haskell ghcid ]; # Prevents cabal from choosing alternate plans, so that # *all* dependencies are provided by Nix. exactDeps = true; } See also: Haskell.nix Library Reference: shellFor","title":"How to get a development shell for a multi-package project"},{"location":"user-guide/development/#how-to-get-a-local-hoogle-index","text":"If you need a local Hoogle for all the dependencies of your project create this file # shell-hoogle.nix let hsPkgs = import ./default.nix {}; in hsPkgs.shellFor { packages = ps: [ps.my-package]; withHoogle = true; } and run nix-shell shell-hoogle.nix --run \"hoogle server --local\" . This will open a local Hoogle server at http://127.0.0.1:8080 .","title":"How to get a local Hoogle index"},{"location":"user-guide/development/#how-to-get-an-ad-hoc-development-shell-including-certain-packages","text":"This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages .","title":"How to get an ad-hoc development shell including certain packages"},{"location":"user-guide/development/#how-to-get-packages-from-a-certain-stackage-snapshot","text":"Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.snapshots. lts-13.18 .alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built.","title":"How to get packages from a certain Stackage snapshot"},{"location":"user-guide/development/#emacs-ide-support","text":"Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl .","title":"Emacs IDE support"},{"location":"user-guide/projects/","text":"How to replace IFDs with intermediate nix files We believe that imports from derivations (IFDs) provide tremendous value in nix and the aversion towards them stems mostly from poor tooling and ci support for them. We do not believe that poor tooling or ci support should cripple nix capability of abstraction. Hence haskell.nix makes excessive use of IFDs. We do note however that there are users who prefer to have IFD-free expressions. For this group of users we detail how to expand the IFD dependent high level functions into their IFD free building blocks. The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression (see the links bellow). The following file then produces a package set: # default.nix let # Import the Haskell.nix library, pkgs = import nixpkgs (import builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = pkgs.haskell-nix.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in stack.yaml instead # (`stack-to-nix` will include them as defaults). ]; }; # Cabal projects use this: pkgSet = pkgs.haskell-nix.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in `cabal.project` instead # (`plan-to-nix` will include them as defaults). ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks. Generating a pkgs.nix for a Stack project Generating a pkgs.nix for a Cabal project","title":"Creating Nix builds for your projects"},{"location":"user-guide/projects/#how-to-replace-ifds-with-intermediate-nix-files","text":"We believe that imports from derivations (IFDs) provide tremendous value in nix and the aversion towards them stems mostly from poor tooling and ci support for them. We do not believe that poor tooling or ci support should cripple nix capability of abstraction. Hence haskell.nix makes excessive use of IFDs. We do note however that there are users who prefer to have IFD-free expressions. For this group of users we detail how to expand the IFD dependent high level functions into their IFD free building blocks. The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression (see the links bellow). The following file then produces a package set: # default.nix let # Import the Haskell.nix library, pkgs = import nixpkgs (import builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = pkgs.haskell-nix.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in stack.yaml instead # (`stack-to-nix` will include them as defaults). ]; }; # Cabal projects use this: pkgSet = pkgs.haskell-nix.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = [ # specific package overrides would go here # example: # packages.cbors.package.ghcOptions = -Werror ; # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # It may be better to set flags in `cabal.project` instead # (`plan-to-nix` will include them as defaults). ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks. Generating a pkgs.nix for a Stack project Generating a pkgs.nix for a Cabal project","title":"How to replace IFDs with intermediate nix files"},{"location":"user-guide/stack-projects/","text":"Here we will look into how to generate the pkgs.nix file for a stack.yaml project. For the full integration see the previous page . Using stack-to-nix With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = lts-12.17 ; extras = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ). Creating the package set Import the generated pkgs.nix and pass to mkStackPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkStackPkgSet { stack-pkgs = import ./pkgs.nix; pkg-def-overlays = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Stack Projects"},{"location":"user-guide/stack-projects/#using-stack-to-nix","text":"With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = lts-12.17 ; extras = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ).","title":"Using stack-to-nix"},{"location":"user-guide/stack-projects/#creating-the-package-set","text":"Import the generated pkgs.nix and pass to mkStackPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkStackPkgSet { stack-pkgs = import ./pkgs.nix; pkg-def-overlays = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Creating the package set"}]}