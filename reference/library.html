<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Haskell.nix Library - Haskell.nix</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Haskell.nix</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> contains a library of functions for creating buildable
package sets from their Nix expression descriptions. The library is
what you get when importing <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>. It might be helpful to
load the library in the <a href="../tutorials/development.html#using-nix-repl">Nix REPL</a> to
test things.</p>
<ul>
<li><a href="#data-structures">Data structures</a> — the kinds of data that you will encounter working with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>.</li>
<li><a href="#top-level-attributes">Top-level attributes</a> — Functions and derivations defined in the Haskell.nix attrset.</li>
<li><a href="#package-set-functions">Package-set functions</a> — Helper functions defined on the <code>hsPkgs</code> package set.</li>
</ul>
<h1 id="data-structures"><a class="header" href="#data-structures">Data structures</a></h1>
<h2 id="package-set"><a class="header" href="#package-set">Package Set</a></h2>
<p>The result of <code>mkPkgSet</code>. This is an application of the NixOS module
system.</p>
<pre><code class="language-nix">{
  options = { ... };
  config = {
    hsPkgs = { ... };
    packages = { ... };
    compiler = {
      version = "X.Y.Z";
      nix-name = "ghcXYZ";
      packages = { ... };
    };
  };
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>options</code></td><td>Module options</td><td>The combination of all options set through the <code>modules</code> argument passed to <code>mkPkgsSet</code>.</td></tr>
<tr><td><code>config</code></td><td></td><td>The result of evaluating and applying the <code>options</code> with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a></td></tr>
<tr><td><code>.hsPkgs</code></td><td>Attrset of <a href="#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>.packages</code></td><td>Attrset of <a href="#haskell-package-descriptions">Haskell Package descriptions</a></td><td>Configuration for each package in <code>hsPkgs</code></td></tr>
<tr><td><code>.compiler</code></td><td>Attrset</td><td></td></tr>
</tbody></table>
</div>
<h2 id="haskell-package-description"><a class="header" href="#haskell-package-description">Haskell Package description</a></h2>
<p>The <em>Haskell package descriptions</em> are values of the
<code>pkgSet.config.packages</code> attrset. These are not derivations, but just
the configuration for building an individual package. The
configuration options are described under <code>packages.&lt;name&gt;</code> in <a href="./modules.html">Module
options</a>.</p>
<h2 id="component-description"><a class="header" href="#component-description">Component description</a></h2>
<p>The <em>component descriptions</em> are values of the
<code>pkgSet.config.packages.&lt;package&gt;.components</code> attrset. These are not
derivations, but just the configuration for building an individual
component. The configuration options are described under
<code>packages.&lt;name&gt;.components.*</code> in <a href="./modules.html">Module options</a>.</p>
<h2 id="haskell-package"><a class="header" href="#haskell-package">Haskell Package</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>Haskell package</em> is a derivation which has a
<code>components</code> attribute. This derivation is actually just for the
package <code>Setup.hs</code> script, and isn't very interesting. To actually use
the package, look within the components structure.</p>
<pre><code class="language-nix">components = {
  library = COMPONENT;
  exes = { NAME = COMPONENT; };
  tests = { NAME = COMPONENT; };
  benchmarks = { NAME = COMPONENT; };
}
</code></pre>
<h2 id="component"><a class="header" href="#component">Component</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>component</em> is a derivation corresponding to a
<a href="https://www.haskell.org/cabal/users-guide/developing-packages.html">Cabal component</a>
of a package.</p>
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<p>A package identifier is an attrset pair of <code>name</code> and <code>version</code>.</p>
<h2 id="extras"><a class="header" href="#extras">Extras</a></h2>
<p>Extras allow adding more packages to the package set. These will be
functions taking a single parameter <code>hackage</code>. They should return an
attrset of package descriptions.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Modules are the primary method of configuring building of the package
set. They are either:</p>
<ol>
<li>an attrset containing <a href="./modules.html">option declarations</a>, or</li>
<li>a function that returns an attrset containing option declarations.</li>
</ol>
<p>If using the function form of a module, the following named parameters
will be passed to it:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>haskellLib</code></td><td>attrset</td><td>The <a href="#haskelllib">haskellLib</a> utility functions.</td></tr>
<tr><td><code>pkgs</code></td><td></td><td>The Nixpkgs collection.</td></tr>
<tr><td><code>pkgconfPkgs</code></td><td></td><td>A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this)</td></tr>
<tr><td><code>buildModules</code></td><td></td><td></td></tr>
<tr><td><code>config</code></td><td></td><td></td></tr>
<tr><td><code>options</code></td><td></td><td></td></tr>
</tbody></table>
</div>
<h1 id="top-level-attributes"><a class="header" href="#top-level-attributes">Top-level attributes</a></h1>
<h2 id="project"><a class="header" href="#project">project'</a></h2>
<p>Function that accepts attribute set with a <code>src</code> attribute and looks for <code>stack.yaml</code> file relative to it.</p>
<p>If file exists, it calls <a href="#stackproject&#x27;">stackProject</a> function. Otherwise it will call <a href="#cabalproject&#x27;">cabalProject</a> function.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">pkgs.haskell-nix.project' {
  # 'cleanGit' cleans a source directory based on the files known by git
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = "haskell-nix-project";
    src = ./.;
  };
}
</code></pre>
<h2 id="stackproject"><a class="header" href="#stackproject">stackProject'</a></h2>
<p>A function calling <a href="#callstacktonix">callStackToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="#mkstackpkgset">mkStackPkgSet</a> passing also
<code>pkg-def-extras</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hsPkgs</code></td><td>Attrset of <a href="#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>stack-nix</code></td><td></td><td><code>projectNix</code> attribute of <a href="#callstacktonix"><code>callStackToNix</code></a> return value</td></tr>
<tr><td><code>shellFor</code></td><td>Function</td><td><a href="#shellfor"><code>shellFor</code></a></td></tr>
<tr><td><code>ghcWithHoogle</code></td><td>Function</td><td><a href="#ghcwithhoogle"><code>ghcWithHoogle</code></a></td></tr>
<tr><td><code>ghcWithPackages</code></td><td>Function</td><td><a href="#ghcwithpackages"><code>ghcWithPackages</code></a></td></tr>
</tbody></table>
</div>
<h2 id="cabalproject"><a class="header" href="#cabalproject">cabalProject'</a></h2>
<p>A function calling <a href="#callcabalprojecttonix">callCabalProjectToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="#mkcabalprojectpkgset">mkCabalProjectPkgSet</a> passing also
<code>pkg-def-extras</code>, <code>extra-hackages</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hsPkgs</code></td><td>Attrset of <a href="#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>plan-nix</code></td><td></td><td><code>projectNix</code> attribute of <a href="#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td></tr>
<tr><td><code>index-state</code></td><td></td><td><code>index-state</code> attribute of <a href="#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td></tr>
<tr><td><code>shellFor</code></td><td>Function</td><td><a href="#shellfor"><code>shellFor</code></a></td></tr>
<tr><td><code>ghcWithHoogle</code></td><td>Function</td><td><a href="#ghcwithhoogle"><code>ghcWithHoogle</code></a></td></tr>
<tr><td><code>ghcWithPackages</code></td><td>Function</td><td><a href="#ghcwithpackages"><code>ghcWithPackages</code></a></td></tr>
<tr><td><code>projectCross</code></td><td>Attrset</td><td>Like <code>pkgs.pkgsCross.&lt;system&gt;</code> from nixpkgs <code>p.projectCross.&lt;system&gt;</code> returns the project results for cross compilation (where system is a member of nixpkgs lib.systems.examples).  So <code>p.projectCross.ghcjs.hsPkgs</code> is the same as <code>hsPkgs</code> but compiled with ghcjs</td></tr>
<tr><td><code>projectVariants</code></td><td>Attrset</td><td>Attribute set of variant for the project, mapped from <code>flake.variants</code> config values</td></tr>
<tr><td><code>appendModule</code></td><td>Function</td><td>Re-eval the project with an extra module (or module list).</td></tr>
<tr><td><code>extend</code> and <code>appendOverlays</code></td><td>Function</td><td>Modify a project, or add attributes, through overlays: <code>p.extend(final: prev: { })</code>. The overlays are carried-over <code>projectCross</code> and <code>appendModule</code> invocations.</td></tr>
</tbody></table>
</div>
<h2 id="project-cabalproject-and-stackproject"><a class="header" href="#project-cabalproject-and-stackproject">project, cabalProject and stackProject</a></h2>
<p>These versions of the function are the same as project', cabalProject'
and stackProject', but <code>hsPkgs</code> attributes are also included in the
return value directly.  That way a package can be referenced as
<code>(project {...}).foo</code> instead of <code>(project' {...}).hsPkgs.foo</code>.</p>
<h2 id="mkstackpkgset"><a class="header" href="#mkstackpkgset">mkStackPkgSet</a></h2>
<p>Creates a <a href="#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>stack-to-nix</code>.</p>
<pre><code class="language-nix">mkStackPkgSet =
    { stack-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>stack-pkgs</code></td><td></td><td><code>import ./pkgs.nix</code> — The imported file generated by <code>stack‑to‑nix</code>.</td></tr>
<tr><td><code>pkg‑def‑extras</code></td><td>List of <a href="#extras">Extras</a></td><td>For overriding the package set.</td></tr>
<tr><td><code>modules</code></td><td>List of <a href="#modules">Modules</a></td><td>For overriding the package set.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="mkcabalprojectpkgset"><a class="header" href="#mkcabalprojectpkgset">mkCabalProjectPkgSet</a></h2>
<p>Creates a <a href="#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>plan-to-nix</code>.</p>
<pre><code class="language-nix">mkCabalProjectPkgSet =
    { plan-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>plan-pkgs</code></td><td></td><td><code>import ./pkgs.nix</code> — The imported file generated by <code>plan‑to‑nix</code>.</td></tr>
<tr><td><code>pkg‑def‑extras</code></td><td>List of <a href="#extras">Extras</a></td><td>For overriding the package set.</td></tr>
<tr><td><code>modules</code></td><td>List of <a href="#modules">Modules</a></td><td>For overriding the package set.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="mkpkgset"><a class="header" href="#mkpkgset">mkPkgSet</a></h2>
<p>This is the base function used by both <code>mkStackPkgSet</code> and
<code>mkCabalProjectPkgSet</code>.</p>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="snapshots"><a class="header" href="#snapshots">snapshots</a></h2>
<p>This is an attrset of <code>hsPkgs</code> packages from Stackage.</p>
<h2 id="haskellpackages"><a class="header" href="#haskellpackages">haskellPackages</a></h2>
<p>A <code>hsPkgs</code> package set, which is one of the recent LTS Haskell
releases from <a href="#snapshots"><code>snapshots</code></a>.</p>
<p>The chosen LTS is updated occasionally in <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, though a
manual process.</p>
<h2 id="nix-tools"><a class="header" href="#nix-tools">nix-tools</a></h2>
<p>A derivation containing the <code>nix-tools</code> <a href="commands.html">command-line tools</a>.</p>
<h2 id="callstacktonix"><a class="header" href="#callstacktonix">callStackToNix</a></h2>
<p>Runs <code>stack-to-nix</code> and produces the output needed for
<code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkStackPkgSet {
    stack-pkgs = (importAndFilterProject (callStackToNix {
      src = ./.;
    })).pkgs;
    pkg-def-extras = [];
    modules = [];
  };
</code></pre>
<h2 id="callcabalprojecttonix"><a class="header" href="#callcabalprojecttonix">callCabalProjectToNix</a></h2>
<p>Runs <code>cabal new-configure</code> and <code>plan-to-nix</code> and produces the output
needed for <code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkCabalProjectPkgSet {
    plan-pkgs = (importAndFilterProject (callCabalProjectToNix {
      index-state = "2019-04-30T00:00:00Z";
      src = ./.;
    })).pkgs;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>Optional name for better error messages.</td></tr>
<tr><td><code>src</code></td><td>Path</td><td>Location of the cabal project files.</td></tr>
<tr><td><code>compiler-nix-name</code></td><td>String</td><td>The name of the ghc compiler to use eg. "ghc9122"</td></tr>
<tr><td><code>index-state</code></td><td>Timestamp</td><td>Optional hackage index-state, eg. "2025-01-10T00:00:00Z".</td></tr>
<tr><td><code>index-sha256</code></td><td>Sha256</td><td>Optional hash of the truncated hackage index-state.</td></tr>
<tr><td><code>plan-sha256</code></td><td>Sha256</td><td>Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation).</td></tr>
<tr><td><code>cabalProject</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile "${src}/cabal.project").</td></tr>
<tr><td><code>cabalProjectLocal</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile "${src}/cabal.project.local").</td></tr>
<tr><td><code>cabalProjectFreeze</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile "${src}/cabal.project.freeze").</td></tr>
<tr><td><code>ghc</code></td><td></td><td>Deprecated. Use <code>compiler-nix-name</code> instead. Optional ghc to use</td></tr>
<tr><td><code>nix-tools</code></td><td></td><td>Optional nix-tools to use</td></tr>
<tr><td><code>hpack</code></td><td></td><td>Optional hpack to use</td></tr>
<tr><td><code>cabal-install</code></td><td></td><td>Optional cabal-install to use</td></tr>
<tr><td><code>configureArgs</code></td><td>String</td><td>Optional extra arguments to pass to <code>cabal new-configure</code> (--enable-tests is included by default, include <code>--disable-tests</code> to override that).</td></tr>
</tbody></table>
</div>
<h2 id="importandfilterproject"><a class="header" href="#importandfilterproject">importAndFilterProject</a></h2>
<p>Imports from a derivation created by <code>callStackToNix</code>
or <code>callCabalProjectToNix</code>.</p>
<p>The result is an attrset with the following values:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pkgs</code></td><td>attrset</td><td>that can be passed to <code>mkStackPkgSet</code> (as <code>stack-pkgs</code>) or <code>mkCabalProjectPkgSet</code> (as <code>plan-pkgs</code>).</td></tr>
<tr><td><code>nix</code></td><td></td><td>this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra).</td></tr>
</tbody></table>
</div>
<h2 id="hackage"><a class="header" href="#hackage">hackage</a></h2>
<h2 id="stackage"><a class="header" href="#stackage">stackage</a></h2>
<h2 id="fetchexternal"><a class="header" href="#fetchexternal">fetchExternal</a></h2>
<h2 id="cleansourcehaskell"><a class="header" href="#cleansourcehaskell">cleanSourceHaskell</a></h2>
<pre><code class="language-nix">cleanSourceHaskell = { src, name ? null }: ...
</code></pre>
<p>Filters a source tree removing common filenames that are not Haskell
build sources.</p>
<p>This can avoid unecessary rebuilds when these files change.</p>
<p>It's recommended to provide <code>name</code> so that the source derivation
remains constant regardless of how it was fetched.</p>
<p>Example:</p>
<pre><code class="language-nix">src = pkgs.haskell-nix.cleanSourceHaskell {
  src = ./.;
  name = "myproject-src";
};
</code></pre>
<h2 id="haskellsourcefilter"><a class="header" href="#haskellsourcefilter">haskellSourceFilter</a></h2>
<pre><code class="language-nix">haskellSourceFilter = name: type: ...
</code></pre>
<p>This is a source filter function which cleans common build products
and files not needed to do a Haskell build from a source directory.</p>
<p>It should be used with <code>pkgs.lib.cleanSourceWith</code>. Alternatively,
use the convenience function <a href="#cleansourcehaskell"><code>cleanSourceHaskell</code></a>.</p>
<h2 id="haskelllib"><a class="header" href="#haskelllib">haskellLib</a></h2>
<p>Assorted functions for operating on <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> data. This is
distinct from <code>pkgs.haskell.lib</code> in the current Nixpkgs Haskell
Infrastructure.</p>
<h3 id="collectcomponents-collectcomponents"><a class="header" href="#collectcomponents-collectcomponents">collectComponents, collectComponents'</a></h3>
<p>Extracts a selection of components from a Haskell <a href="#package-set">package set</a>.</p>
<p>This can be used to filter out all test suites or benchmarks of
your project, so that they can be built in Hydra (see check if you
want to run the tests as well as build them).</p>
<p><code>collectComponents'</code> is an alias of <code>collectComponents</code> without
predicate for filtering.</p>
<pre><code class="language-nix">collectComponents =
    group: packageSel: haskellPackages: ...
collectComponents' = group: collectComponents (_: true)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>group</code></td><td>String</td><td>A <a href="#subComponentTypes">sub-component type</a>.</td></tr>
<tr><td><code>packageSel</code></td><td>A function <code>Package -&gt; Bool</code></td><td>A predicate to filter packages with.</td></tr>
<tr><td><code>haskellPackages</code></td><td><a href="#package-set">Package set</a></td><td>All packages in the build.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a recursive attrset mapping package names → component names → components.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">tests = collectComponents "tests" (package: package.identifier.name == "mypackage") hsPkgs;
</code></pre>
<p>Will result in moving derivations from <code>hsPkgs.mypackage.components.tests.unit-tests</code>
to <code>tests.mypackage.unit-tests</code>.</p>
<h3 id="collectchecks-collectchecks"><a class="header" href="#collectchecks-collectchecks">collectChecks, collectChecks'</a></h3>
<p>These are just like <code>collectComponents</code> and <code>collectComponents'</code>, except that they collect
the <code>checks</code> attributes of packages (which aren't components, and so can't be collected
by the other functions.</p>
<h4 id="check"><a class="header" href="#check">check</a></h4>
<p>This function turns a derivation that builds a test into one to run it.</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>drv</code></td><td>Derivation</td><td>One of <code>$pkg.components.tests.$test</code>.</td></tr>
</tbody></table>
</div>
<p>For convenience <code>$pkg.components.tests</code> are mapped with this function
to <code>$pkg.checks</code>.</p>
<p>This function is intended for use with <code>tests</code> but it should also work
for <code>exes</code> and <code>benchmarks</code> if you just want to run them to make sure
they execute.</p>
<h4 id="subcomponenttypes"><a class="header" href="#subcomponenttypes">subComponentTypes</a></h4>
<p>Sub-component types identify <a href="#component">components</a> and are one of:</p>
<ul>
<li><code>sublibs</code></li>
<li><code>foreignlibs</code></li>
<li><code>exes</code></li>
<li><code>tests</code></li>
<li><code>benchmarks</code></li>
</ul>
<h1 id="project-functions"><a class="header" href="#project-functions">Project functions</a></h1>
<p>These functions are included in the <code>project</code> return values.
In the past they also existed within <code>project.hsPkgs</code>,
but have now been removed from there.</p>
<h2 id="shellfor"><a class="header" href="#shellfor">shellFor</a></h2>
<p>Create a <code>nix-shell</code> <a href="../tutorials/development.html">development
environment</a> for developing one or more
packages with <code>ghci</code> or <code>cabal v2-build</code> (but not Stack).</p>
<pre><code class="language-nix">shellFor =
    { packages, withHoogle ? true, exactDeps ? false, ...}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>Name of the derivation</td></tr>
<tr><td><code>packages</code></td><td>Function</td><td>Package selection function. It takes a list of <a href="#haskell-package">Haskell packages</a> and returns a subset of these packages.</td></tr>
<tr><td><code>components</code></td><td>Function</td><td>Similar to <code>packages</code>, by default all the components of the selected packages are selected.</td></tr>
<tr><td><code>additional</code></td><td>Function</td><td>Similar to <code>packages</code>, but the selected packages are built and included in <code>ghc-pkg list</code> (not just their dependencies).</td></tr>
<tr><td><code>withHoogle</code></td><td>Boolean</td><td>Whether to build a Hoogle documentation index and provide the <code>hoogle</code> command.</td></tr>
<tr><td><code>exactDeps</code></td><td>Boolean</td><td>Prevents the Cabal solver from choosing any package dependency other than what are in the package set.</td></tr>
<tr><td><code>allToolDeps</code></td><td>Boolean</td><td>Indicates if the shell should include all the tool dependencies of the haskell packages in the project.</td></tr>
<tr><td><code>tools</code></td><td>Function</td><td>AttrSet of tools to make available e.g. <code>{ cabal = "3.2.0.0"; }</code> or <code>{ cabal = { version = "3.2.0.0"; }; }</code>. If an AttrSet is provided for a tool, the additional arguments will be passed to the function creating the derivation for that tool. So you can provide an <code>index-state</code> or a <code>materialized</code> argument like that <code>{ cabal = { version = "3.2.0.0"; index-state = "2020-10-30T00:00:00Z"; materialized = ./cabal.materialized; }; }</code> for example. You can specify and materialize the version of hoogle used to construct the hoogle index by including something like <code>{ hoogle = { version = "5.0.17.15"; index-state = "2020-05-31T00:00:00Z"; materialized = ./hoogle.materialized; }</code>. Uses a default version of hoogle if omitted.</td></tr>
<tr><td><code>packageSetupDeps</code></td><td>Boolean</td><td>Set this to <code>false</code> to exclude custom-setup dependencies.</td></tr>
<tr><td><code>enableDWARF</code></td><td>Boolean</td><td>Include debug info</td></tr>
<tr><td><code>crossPlatforms</code></td><td>Function</td><td>Platform selection function for cross compilation targets to support eg. <code>ps: with ps; [ghcjs mingwW64]</code> (see nixpkgs lib.systems.examples for list of platform names).</td></tr>
<tr><td><code>inputsFrom</code></td><td>List</td><td>List of other shells to include in this one.  The <code>buildInputs</code> and <code>nativeBuildInputs</code> of each will be included using <a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell">mkShell</a>.</td></tr>
<tr><td><code>shellHook</code></td><td>String</td><td>Bash statements that are executed when the shell starts.</td></tr>
<tr><td><code>buildInputs</code></td><td></td><td>Passed to <a href="https://nixos.org/nixpkgs/manual/#sec-using-stdenv"><code>mkDerivation</code></a> (via <a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell">mkShell</a>).</td></tr>
<tr><td><code>nativeBuildInputs</code></td><td></td><td>Passed to <a href="https://nixos.org/nixpkgs/manual/#sec-using-stdenv"><code>mkDerivation</code></a> (via <a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell">mkShell</a>).</td></tr>
<tr><td><code>passthru</code></td><td></td><td>Passed to <a href="https://nixos.org/nixpkgs/manual/#sec-using-stdenv"><code>mkDerivation</code></a>  (via <a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell">mkShell</a>).</td></tr>
</tbody></table>
</div>
<p>The arguments are checked using the module <code>modules/shell.nix</code>.</p>
<p>To set environment variables in the shell use:</p>
<pre><code>  shellHook = ''
    export FOO="bar"
  '';
</code></pre>
<p>or</p>
<pre><code>(p.shellFor {}).overrideAttrs {
   FOO = "bar";
}
</code></pre>
<p>The <code>shellFor</code> arguments can also be passed to the project <code>shell</code>
argument.  For instance:</p>
<pre><code>(pkgs.haskell-nix.project {
  ...
  shell.tools.cabal = {}
).shellFor {}
</code></pre>
<p>Is the same as:</p>
<pre><code>(pkgs.haskell-nix.project {
  ...
).shellFor {
  tools.cabal = {}
}
</code></pre>
<p><strong>Return value</strong>: a derivation</p>
<blockquote>
<p>⚠️ <strong>Warning:</strong></p>
<p><code>exactDeps = true</code> will set the <code>CABAL_CONFIG</code> environment variable
to disable remote package servers. This is a
<a href="../dev/removing-with-package-wrapper.html">known limitation</a>
which we would like to solve. Use <code>exactDeps = false</code> if this is a
problem.</p>
</blockquote>
<h2 id="ghcwithpackages"><a class="header" href="#ghcwithpackages">ghcWithPackages</a></h2>
<p>Creates a <code>nix-shell</code> <a href="../tutorials/development.html">development
environment</a> including the given
packages selected from this package set.</p>
<p><strong>Parameter</strong>: a package selection function.</p>
<p><strong>Return value</strong>: a derivation</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ])
</code></pre>
<h2 id="ghcwithhoogle"><a class="header" href="#ghcwithhoogle">ghcWithHoogle</a></h2>
<p>The same as <code>ghcWithPackages</code>, except, a <code>hoogle</code> command with a
Hoogle documentation index of the packages will be included in the
shell.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/commands.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/modules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/commands.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/modules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
