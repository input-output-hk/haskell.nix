diff --git a/clang/lib/Driver/ToolChains/WebAssembly.cpp b/clang/lib/Driver/ToolChains/WebAssembly.cpp
index 5054868b5ff4..e4fcd949ff71 100644
--- a/clang/lib/Driver/ToolChains/WebAssembly.cpp
+++ b/clang/lib/Driver/ToolChains/WebAssembly.cpp
@@ -6,6 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include <sstream>
+
 #include "WebAssembly.h"
 #include "Gnu.h"
 #include "clang/Config/config.h"
@@ -17,6 +19,7 @@
 #include "llvm/Option/ArgList.h"
 #include "llvm/Support/FileSystem.h"
 #include "llvm/Support/Path.h"
+#include "llvm/Support/Process.h"
 #include "llvm/Support/VirtualFileSystem.h"
 
 using namespace clang::driver;
@@ -179,21 +182,12 @@ void wasm::Linker::ConstructJob(Compilation &C, const JobAction &JA,
   CmdArgs.push_back("-o");
   CmdArgs.push_back(Output.getFilename());
 
-  // Don't use wasm-opt by default on `wasip2` as it doesn't have support for
-  // components at this time. Retain the historical default otherwise, though,
-  // of running `wasm-opt` by default.
-  bool WasmOptDefault = !TargetBuildsComponents(ToolChain.getTriple());
-  bool RunWasmOpt = Args.hasFlag(options::OPT_wasm_opt,
-                                 options::OPT_no_wasm_opt, WasmOptDefault);
-
   // If wasm-opt is enabled and optimizations are happening look for the
   // `wasm-opt` program. If it's not found auto-disable it.
   std::string WasmOptPath;
-  if (RunWasmOpt && Args.getLastArg(options::OPT_O_Group)) {
-    WasmOptPath = ToolChain.GetProgramPath("wasm-opt");
-    if (WasmOptPath == "wasm-opt") {
-      WasmOptPath = {};
-    }
+  WasmOptPath = ToolChain.GetProgramPath("wasm-opt");
+  if (WasmOptPath == "wasm-opt") {
+    WasmOptPath = {};
   }
 
   if (!WasmOptPath.empty()) {
@@ -204,29 +198,27 @@ void wasm::Linker::ConstructJob(Compilation &C, const JobAction &JA,
                                          ResponseFileSupport::AtFileCurCP(),
                                          Linker, CmdArgs, Inputs, Output));
 
-  if (Arg *A = Args.getLastArg(options::OPT_O_Group)) {
-    if (!WasmOptPath.empty()) {
-      StringRef OOpt = "s";
-      if (A->getOption().matches(options::OPT_O4) ||
-          A->getOption().matches(options::OPT_Ofast))
-        OOpt = "4";
-      else if (A->getOption().matches(options::OPT_O0))
-        OOpt = "0";
-      else if (A->getOption().matches(options::OPT_O))
-        OOpt = A->getValue();
-
-      if (OOpt != "0") {
-        const char *WasmOpt = Args.MakeArgString(WasmOptPath);
-        ArgStringList OptArgs;
-        OptArgs.push_back(Output.getFilename());
-        OptArgs.push_back(Args.MakeArgString(llvm::Twine("-O") + OOpt));
-        OptArgs.push_back("-o");
-        OptArgs.push_back(Output.getFilename());
-        C.addCommand(std::make_unique<Command>(
-            JA, *this, ResponseFileSupport::AtFileCurCP(), WasmOpt, OptArgs,
-            Inputs, Output));
-      }
+  if (!WasmOptPath.empty() && Args.hasArg(options::OPT_shared) &&
+      llvm::sys::Process::GetEnv("WASM_SO_OPT")) {
+    const char *WasmOpt = Args.MakeArgString(WasmOptPath);
+    ArgStringList OptArgs;
+    OptArgs.push_back(Output.getFilename());
+    OptArgs.push_back("-o");
+    OptArgs.push_back(Output.getFilename());
+
+    std::istringstream iss(llvm::sys::Process::GetEnv("WASM_SO_OPT").value());
+    std::string arg;
+
+    while (iss >> arg) {
+      auto *arg_heap = new char[arg.size() + 1];
+      std::copy(arg.begin(), arg.end(), arg_heap);
+      arg_heap[arg.size()] = '\0';
+      OptArgs.push_back(arg_heap);
     }
+
+    C.addCommand(std::make_unique<Command>(JA, *this,
+                                           ResponseFileSupport::AtFileCurCP(),
+                                           WasmOpt, OptArgs, Inputs, Output));
   }
 }
 
diff --git a/compiler-rt/cmake/Modules/AddCompilerRT.cmake b/compiler-rt/cmake/Modules/AddCompilerRT.cmake
index fb2aee8e42ee..a5de2dca1bc9 100644
--- a/compiler-rt/cmake/Modules/AddCompilerRT.cmake
+++ b/compiler-rt/cmake/Modules/AddCompilerRT.cmake
@@ -390,8 +390,8 @@ function(add_compiler_rt_runtime name type)
       target_link_libraries(${libname} PRIVATE ${builtins_${libname}})
     endif()
     if(${type} STREQUAL "SHARED")
-      if(APPLE OR WIN32)
-        set_property(TARGET ${libname} PROPERTY BUILD_WITH_INSTALL_RPATH ON)
+      if(COMMAND llvm_setup_rpath)
+        llvm_setup_rpath(${libname})
       endif()
       if(WIN32 AND NOT CYGWIN AND NOT MINGW)
         set_target_properties(${libname} PROPERTIES IMPORT_PREFIX "")
diff --git a/lld/wasm/InputChunks.cpp b/lld/wasm/InputChunks.cpp
index 181221a77b10..c813e62e7b93 100644
--- a/lld/wasm/InputChunks.cpp
+++ b/lld/wasm/InputChunks.cpp
@@ -409,12 +409,11 @@ uint64_t InputChunk::getVA(uint64_t offset) const {
 // Generate code to apply relocations to the data section at runtime.
 // This is only called when generating shared libraries (PIC) where address are
 // not known at static link time.
-bool InputChunk::generateRelocationCode(raw_ostream &os) const {
+void InputChunk::generateRelocationCode(std::vector<std::string> &funcs) const {
   LLVM_DEBUG(dbgs() << "generating runtime relocations: " << name
                     << " count=" << relocations.size() << "\n");
 
   bool is64 = ctx.arg.is64.value_or(false);
-  bool generated = false;
   unsigned opcode_ptr_const = is64 ? WASM_OPCODE_I64_CONST
                                    : WASM_OPCODE_I32_CONST;
   unsigned opcode_ptr_add = is64 ? WASM_OPCODE_I64_ADD
@@ -433,6 +432,14 @@ bool InputChunk::generateRelocationCode(raw_ostream &os) const {
     if (!requiresRuntimeReloc)
       continue;
 
+    if (funcs.empty() || funcs.back().size() >= 7654300) {
+      funcs.emplace_back(std::string());
+      raw_string_ostream os(funcs.back());
+      writeUleb128(os, 0, "num locals");
+    }
+
+    raw_string_ostream os(funcs.back());
+
     LLVM_DEBUG(dbgs() << "gen reloc: type=" << relocTypeToString(rel.Type)
                       << " addend=" << rel.Addend << " index=" << rel.Index
                       << " output offset=" << offset << "\n");
@@ -487,9 +494,7 @@ bool InputChunk::generateRelocationCode(raw_ostream &os) const {
     writeU8(os, opcode_reloc_store, "I32_STORE");
     writeUleb128(os, 2, "align");
     writeUleb128(os, 0, "offset");
-    generated = true;
   }
-  return generated;
 }
 
 // Split WASM_SEG_FLAG_STRINGS section. Such a section is a sequence of
diff --git a/lld/wasm/InputChunks.h b/lld/wasm/InputChunks.h
index 1fe78d76631f..2c721f5f92e8 100644
--- a/lld/wasm/InputChunks.h
+++ b/lld/wasm/InputChunks.h
@@ -79,7 +79,7 @@ public:
   size_t getNumRelocations() const { return relocations.size(); }
   size_t getNumLiveRelocations() const;
   void writeRelocations(llvm::raw_ostream &os) const;
-  bool generateRelocationCode(raw_ostream &os) const;
+  void generateRelocationCode(std::vector<std::string> &funcs) const;
 
   bool isTLS() const { return flags & llvm::wasm::WASM_SEG_FLAG_TLS; }
   bool isRetained() const { return flags & llvm::wasm::WASM_SEG_FLAG_RETAIN; }
diff --git a/lld/wasm/SyntheticSections.cpp b/lld/wasm/SyntheticSections.cpp
index e1192706ea91..1b97039b1f1f 100644
--- a/lld/wasm/SyntheticSections.cpp
+++ b/lld/wasm/SyntheticSections.cpp
@@ -312,6 +312,8 @@ void FunctionSection::writeBody() {
 void FunctionSection::addFunction(InputFunction *func) {
   if (!func->live)
     return;
+  if (func->hasFunctionIndex())
+    return;
   uint32_t functionIndex =
       out.importSec->getNumImportedFunctions() + inputFunctions.size();
   inputFunctions.emplace_back(func);
diff --git a/lld/wasm/Writer.cpp b/lld/wasm/Writer.cpp
index b704677d36c9..ac9eab2b9dd5 100644
--- a/lld/wasm/Writer.cpp
+++ b/lld/wasm/Writer.cpp
@@ -1455,20 +1455,21 @@ void Writer::createStartFunction() {
 void Writer::createApplyDataRelocationsFunction() {
   LLVM_DEBUG(dbgs() << "createApplyDataRelocationsFunction\n");
   // First write the body's contents to a string.
-  std::string bodyContent;
+  std::vector<std::string> funcs;
   {
-    raw_string_ostream os(bodyContent);
-    writeUleb128(os, 0, "num locals");
-    bool generated = false;
     for (const OutputSegment *seg : segments)
       if (!ctx.arg.sharedMemory || !seg->isTLS())
         for (const InputChunk *inSeg : seg->inputSegments)
-          generated |= inSeg->generateRelocationCode(os);
+          inSeg->generateRelocationCode(funcs);
+  }
 
-    if (!generated) {
-      LLVM_DEBUG(dbgs() << "skipping empty __wasm_apply_data_relocs\n");
-      return;
-    }
+  if (funcs.empty()) {
+    LLVM_DEBUG(dbgs() << "skipping empty __wasm_apply_data_relocs\n");
+    return;
+  }
+
+  for (auto &func : funcs) {
+    raw_string_ostream os(func);
     writeU8(os, WASM_OPCODE_END, "END");
   }
 
@@ -1481,24 +1482,67 @@ void Writer::createApplyDataRelocationsFunction() {
       make<SyntheticFunction>(nullSignature, "__wasm_apply_data_relocs"));
   def->markLive();
 
-  createFunction(def, bodyContent);
+  if (funcs.size() == 1) {
+    createFunction(def, funcs.back());
+    return;
+  }
+
+  std::string body;
+  {
+    raw_string_ostream os(body);
+    writeUleb128(os, 0, "num locals");
+
+    for (std::size_t i = 0; i < funcs.size(); ++i) {
+      auto &name =
+          *make<std::string>("__wasm_apply_data_relocs_" + std::to_string(i));
+      auto *func = make<SyntheticFunction>(nullSignature, name);
+      auto *def = symtab->addSyntheticFunction(
+          name, WASM_SYMBOL_VISIBILITY_HIDDEN, func);
+      def->markLive();
+      // Normally this shouldn't be called manually for a synthetic
+      // function, since the function indices in
+      // ctx.syntheticFunctions will be calculated later (check
+      // functionSec->addFunction call hierarchy for details).
+      // However, at this point we already need the correct index. The
+      // solution is to place the new synthetic function eagerly, and
+      // also making addFunction idempotent by skipping when there's
+      // already a function index.
+      out.functionSec->addFunction(func);
+      createFunction(def, funcs[i]);
+
+      writeU8(os, WASM_OPCODE_CALL, "CALL");
+      writeUleb128(os, def->getFunctionIndex(), "function index");
+    }
+
+    writeU8(os, WASM_OPCODE_END, "END");
+  }
+  createFunction(def, body);
 }
 
 void Writer::createApplyTLSRelocationsFunction() {
   LLVM_DEBUG(dbgs() << "createApplyTLSRelocationsFunction\n");
-  std::string bodyContent;
+  std::vector<std::string> funcs;
   {
-    raw_string_ostream os(bodyContent);
-    writeUleb128(os, 0, "num locals");
     for (const OutputSegment *seg : segments)
       if (seg->isTLS())
         for (const InputChunk *inSeg : seg->inputSegments)
-          inSeg->generateRelocationCode(os);
+          inSeg->generateRelocationCode(funcs);
+  }
 
+  if (funcs.empty()) {
+    funcs.emplace_back(std::string());
+    raw_string_ostream os(funcs.back());
+    writeUleb128(os, 0, "num locals");
+  }
+
+  for (auto &func : funcs) {
+    raw_string_ostream os(func);
     writeU8(os, WASM_OPCODE_END, "END");
   }
 
-  createFunction(ctx.sym.applyTLSRelocs, bodyContent);
+  assert(funcs.size() == 1);
+
+  createFunction(ctx.sym.applyTLSRelocs, funcs.back());
 }
 
 // Similar to createApplyDataRelocationsFunction but generates relocation code
diff --git a/llvm/cmake/modules/AddLLVM.cmake b/llvm/cmake/modules/AddLLVM.cmake
index 83772ed8d2b1..0a7360d9357a 100644
--- a/llvm/cmake/modules/AddLLVM.cmake
+++ b/llvm/cmake/modules/AddLLVM.cmake
@@ -2547,8 +2547,7 @@ function(llvm_setup_rpath name)
     # FIXME: update this when there is better solution.
     set(_install_rpath "${LLVM_LIBRARY_OUTPUT_INTDIR}" "${CMAKE_INSTALL_PREFIX}/lib${LLVM_LIBDIR_SUFFIX}" ${extra_libdir})
   elseif(UNIX)
-    set(_build_rpath "\$ORIGIN/../lib${LLVM_LIBDIR_SUFFIX}" ${extra_libdir})
-    set(_install_rpath "\$ORIGIN/../lib${LLVM_LIBDIR_SUFFIX}")
+    set(_install_rpath "\$ORIGIN/../lib${LLVM_LIBDIR_SUFFIX}" ${extra_libdir})
     if(${CMAKE_SYSTEM_NAME} MATCHES "(FreeBSD|DragonFly)")
       set_property(TARGET ${name} APPEND_STRING PROPERTY
                    LINK_FLAGS " -Wl,-z,origin ")
@@ -2562,16 +2561,9 @@ function(llvm_setup_rpath name)
     return()
   endif()
 
-  # Enable BUILD_WITH_INSTALL_RPATH unless CMAKE_BUILD_RPATH is set and not
-  # building for macOS or AIX, as those platforms seemingly require it.
-  # On AIX, the tool chain doesn't support modifying rpaths/libpaths for XCOFF
-  # on install at the moment, so BUILD_WITH_INSTALL_RPATH is required.
+  # Enable BUILD_WITH_INSTALL_RPATH unless CMAKE_BUILD_RPATH is set.
   if("${CMAKE_BUILD_RPATH}" STREQUAL "")
-    if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin|AIX")
-      set_property(TARGET ${name} PROPERTY BUILD_WITH_INSTALL_RPATH ON)
-    else()
-      set_property(TARGET ${name} APPEND PROPERTY BUILD_RPATH "${_build_rpath}")
-    endif()
+    set_property(TARGET ${name} PROPERTY BUILD_WITH_INSTALL_RPATH ON)
   endif()
 
   set_target_properties(${name} PROPERTIES
diff --git a/llvm/lib/MC/MCParser/WasmAsmParser.cpp b/llvm/lib/MC/MCParser/WasmAsmParser.cpp
index 1f824b80bcd4..1025d3ee3026 100644
--- a/llvm/lib/MC/MCParser/WasmAsmParser.cpp
+++ b/llvm/lib/MC/MCParser/WasmAsmParser.cpp
@@ -228,7 +228,13 @@ public:
     if (WasmSym->isFunction()) {
       // Ignore .size directives for function symbols.  They get their size
       // set automatically based on their content.
-      Warning(Loc, ".size directive ignored for function symbols");
+      //
+      // Upstream LLVM treats this as a warning, we turn this into an
+      // error since it almost certainly signals severely malformed
+      // assembly due to miscompilation, and data/function symbol kind
+      // confusion is not always caught at link-time and might
+      // manifest as wasm runtime crashes :/
+      Error(Loc, ".size directive ignored for function symbols");
     } else {
       getStreamer().emitELFSize(Sym, Expr);
     }
diff --git a/llvm/test/MC/WebAssembly/function-size-warning.s b/llvm/test/MC/WebAssembly/function-size-warning.s
index 627002dd3578..fd410d9ae67c 100644
--- a/llvm/test/MC/WebAssembly/function-size-warning.s
+++ b/llvm/test/MC/WebAssembly/function-size-warning.s
@@ -12,4 +12,4 @@ foo:
 # assembly files.
 .size foo, 0
 
-# CHECK: warning: .size directive ignored for function symbols
+# CHECK-ERROR: error: .size directive ignored for function symbols
diff --git a/llvm/test/MC/WebAssembly/null-output.s b/llvm/test/MC/WebAssembly/null-output.s
index fb15eecffc86..513e37d35039 100644
--- a/llvm/test/MC/WebAssembly/null-output.s
+++ b/llvm/test/MC/WebAssembly/null-output.s
@@ -1,4 +1,5 @@
 # RUN: llvm-mc -triple=wasm32-unknown-unknown -filetype=obj -o /dev/null < %s
+# XFAIL: *
 
     .text
     .section .text.main,"",@
